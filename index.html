

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light" />
  <title>Work Orders List – Aberdeen Laundry Services (Engineering)</title>
<style>
:root{
  --bg:#f3f5f9;
  --paper:#ffffff;
  --ink:#0b0f1a;
  --muted:#6b7280;
  --border:#e5e9f2;

  --brand:#0b67c2;
  --brand-strong:#0a5cb0;

  /* Buttons (auto in both themes) */
  --btn-fg:#ffffff;
  --btn-bg:var(--brand);
  --btn-bg-hover:var(--brand-strong);
  --btn-outline-fg:var(--brand);
  --btn-outline-bd:#bcd7f4;
  --btn-ghost-fg:var(--brand);
  --btn-ghost-bg:transparent;
  --btn-ghost-bg-hover:rgba(11,103,194,.10);

  /* Inputs */
  --input-bg:#ffffff;
  --input-fg:var(--ink);
  --input-bd:var(--border);
  --input-bd-focus:var(--brand);
  --card-bg:color-mix(in srgb, var(--paper) 96%, var(--bg));
  --card-border:color-mix(in srgb, var(--border) 70%, transparent);
  --card-shadow-rest:0 1px 2px rgba(15,23,42,.08),0 4px 10px rgba(15,23,42,.06);
  --card-shadow-hover:0 6px 18px rgba(15,23,42,.14),0 4px 12px rgba(15,23,42,.08);
  --chip-bg:color-mix(in srgb, var(--brand) 12%, var(--paper));
  --chip-ink:color-mix(in srgb, var(--brand) 36%, var(--ink));
  --accent-blue:#2563eb;
  --accent-amber:#f59e0b;
  --accent-red:#ef4444;
  --accent-grey:#6b7280;
  --shadow:0 1px 2px rgba(16,24,40,.06),0 4px 10px rgba(16,24,40,.06);

  /* Legacy tokens */
  --als-blue:var(--brand);
  --als-blue-strong:var(--brand-strong);
  --thead:var(--brand);
  --thead-text:#fff;
  --grid:var(--border);
  --zebra:var(--paper);
  --done-tx:#059669;
  --open-tx:var(--brand);
  --hold-tx:#b45309;
  --done-bg:#0596691a;
  --open-bg:#0b67c21a;
  --hold-bg:#f59e0b1a;
  --priority-rail:#E85A70;
  --sticky-controls-offset:0px;
  --ui-offset:0px;
  --table-min-width:1100px;
  --winter-night-start:#020b1f;
  --winter-night-mid:color-mix(in srgb,#020b1f 55%,#08163a 45%);
  --winter-night-end:#08163a;
  --winter-night-far:color-mix(in srgb,#020b1f 20%,#08163a 80%);
  --winter-moon:#fff4d2;
  --winter-star:#ffffff;
  --surface-glass:color-mix(in srgb,var(--brand) 18%,color-mix(in srgb,var(--paper) 70%,transparent));
  --surface-glass-strong:color-mix(in srgb,var(--brand) 26%,color-mix(in srgb,var(--paper) 62%,transparent));
  --surface-border:color-mix(in srgb,var(--brand) 45%,transparent);
}

/* REVERT to default page scroll */
html, body{
  height:auto;       /* was 100% */
  overflow:auto;     /* was hidden */
  /* remove overscroll-behavior if you added it */
}
/* column width vars for both the bar and table */
:root{
  --col-id:66px; --col-title:280px; --col-status:120px; --col-priority:92px;
  --col-assigned:160px; --col-created:110px; --col-updated:120px;
  --col-completed:110px; --col-age:96px; --col-location:180px;
  --col-asset:220px; --col-categories:160px;
}

@media (prefers-color-scheme: dark){
  :root{
    color-scheme:dark;
    --bg:#0f1422;
    --paper:#131a2b;
    --ink:#f3f4f6;
    --muted:#9ca3af;
    --border:#233150;
    --brand:#3b82f6;
    --brand-strong:#2563eb;
    --btn-outline-bd:#2b3a63;
    --btn-ghost-bg-hover:rgba(11,103,194,.18);
    --input-bg:#0f1422;
    --input-fg:#f3f4f6;
    --input-bd:#233150;
    --input-bd-focus:#3b82f6;
    --card-bg:color-mix(in srgb, var(--paper) 94%, var(--bg));
    --card-border:color-mix(in srgb, var(--border) 80%, transparent);
    --card-shadow-rest:0 1px 2px rgba(0,0,0,.48),0 4px 12px rgba(0,0,0,.42);
    --card-shadow-hover:0 6px 20px rgba(0,0,0,.55),0 3px 12px rgba(0,0,0,.5);
    --chip-bg:color-mix(in srgb, var(--brand) 16%, var(--paper));
    --chip-ink:color-mix(in srgb, var(--brand) 60%, var(--ink));
    --accent-blue:#60a5fa;
    --accent-amber:#fbbf24;
    --accent-red:#f87171;
    --accent-grey:#9ca3af;
    --als-blue:var(--brand);
    --als-blue-strong:var(--brand-strong);
    --thead:#1e3a8a;
    --grid:#233150;
    --zebra:#1c2438;
    --done-tx:#10b981;
    --open-tx:var(--brand);
    --hold-tx:#fbbf24;
    --done-bg:#10b98133;
    --open-bg:#3b82f633;
    --hold-bg:#f59e0b33;
    --surface-glass:color-mix(in srgb,var(--brand) 20%,color-mix(in srgb,var(--paper) 62%,transparent));
    --surface-glass-strong:color-mix(in srgb,var(--brand) 30%,color-mix(in srgb,var(--paper) 56%,transparent));
    --surface-border:color-mix(in srgb,var(--brand) 38%,transparent);
    --ctrl-bg:#0d1117;
    --ctrl-fg:#e8edf5;
    --ctrl-muted:#9aa7b7;
    --ctrl-ring:#60a5fa;
    --ctrl-pill:#111827;
    --ctrl-pill-border:#1f2937;
    --ctrl-shadow:0 1px 0 rgba(255,255,255,.06) inset;
    --ctrl-hover:rgba(96,165,250,.15);
    --ctrl-on:#60a5fa;
  }
}

.dark{
  color-scheme:dark;
  --bg:#0f1422;
  --paper:#131a2b;
  --ink:#f3f4f6;
  --muted:#9ca3af;
  --border:#233150;
  --brand:#3b82f6;
  --brand-strong:#2563eb;
  --btn-outline-bd:#2b3a63;
  --btn-ghost-bg-hover:rgba(11,103,194,.18);
  --input-bg:#0f1422;
  --input-fg:#f3f4f6;
  --input-bd:#233150;
  --input-bd-focus:#3b82f6;
  --card-bg:color-mix(in srgb, var(--paper) 94%, var(--bg));
  --card-border:color-mix(in srgb, var(--border) 80%, transparent);
  --card-shadow-rest:0 1px 2px rgba(0,0,0,.48),0 4px 12px rgba(0,0,0,.42);
  --card-shadow-hover:0 6px 20px rgba(0,0,0,.55),0 3px 12px rgba(0,0,0,.5);
  --chip-bg:color-mix(in srgb, var(--brand) 16%, var(--paper));
  --chip-ink:color-mix(in srgb, var(--brand) 60%, var(--ink));
  --accent-blue:#60a5fa;
  --accent-amber:#fbbf24;
  --accent-red:#f87171;
  --accent-grey:#9ca3af;
  --als-blue:var(--brand);
  --als-blue-strong:var(--brand-strong);
  --thead:#1e3a8a;
  --grid:#233150;
  --zebra:#1c2438;
  --done-tx:#10b981;
  --open-tx:var(--brand);
  --hold-tx:#fbbf24;
  --done-bg:#10b98133;
  --open-bg:#3b82f633;
  --hold-bg:#f59e0b33;
  --surface-glass:color-mix(in srgb,var(--brand) 20%,color-mix(in srgb,var(--paper) 62%,transparent));
  --surface-glass-strong:color-mix(in srgb,var(--brand) 30%,color-mix(in srgb,var(--paper) 56%,transparent));
  --surface-border:color-mix(in srgb,var(--brand) 38%,transparent);
}
.light{
  color-scheme:light;
  --bg:#f3f5f9;
  --paper:#ffffff;
  --ink:#0b0f1a;
  --muted:#6b7280;
  --border:#e5e9f2;
  --brand:#0b67c2;
  --brand-strong:#0a5cb0;
  --btn-outline-bd:#bcd7f4;
  --btn-ghost-bg-hover:rgba(11,103,194,.10);
  --input-bg:#ffffff;
  --input-fg:var(--ink);
  --input-bd:var(--border);
  --input-bd-focus:var(--brand);
  --als-blue:var(--brand);
  --als-blue-strong:var(--brand-strong);
  --thead:var(--brand);
  --grid:var(--border);
  --zebra:var(--paper);
  --done-tx:#059669;
  --open-tx:var(--brand);
  --hold-tx:#b45309;
  --done-bg:#0596691a;
  --open-bg:#0b67c21a;
  --hold-bg:#f59e0b1a;
  --surface-glass:color-mix(in srgb,var(--brand) 18%,color-mix(in srgb,var(--paper) 70%,transparent));
  --surface-glass-strong:color-mix(in srgb,var(--brand) 26%,color-mix(in srgb,var(--paper) 62%,transparent));
  --surface-border:color-mix(in srgb,var(--brand) 45%,transparent);
}

:root{
  --ctrl-bg:#ffffff;
  --ctrl-fg:#0b0f1a;
  --ctrl-muted:#6b7280;
  --ctrl-ring:#3b82f6;
  --ctrl-pill:#f3f6fb;
  --ctrl-pill-border:#dfe6ef;
  --ctrl-shadow:0 1px 2px rgba(0,0,0,.05);
  --ctrl-hover:rgba(11,103,194,.08);
  --ctrl-on:#0b67c2;
}
:root[color-scheme="dark"],
.theme-dark,
.dark,
body.dark{
  --ctrl-bg:#0d1117;
  --ctrl-fg:#e8edf5;
  --ctrl-muted:#9aa7b7;
  --ctrl-ring:#60a5fa;
  --ctrl-pill:#111827;
  --ctrl-pill-border:#1f2937;
  --ctrl-shadow:0 1px 0 rgba(255,255,255,.06) inset;
  --ctrl-hover:rgba(96,165,250,.15);
  --ctrl-on:#60a5fa;
  --card-bg:color-mix(in srgb, var(--paper) 94%, var(--bg));
  --card-border:color-mix(in srgb, var(--border) 80%, transparent);
  --card-shadow-rest:0 1px 2px rgba(0,0,0,.48),0 4px 12px rgba(0,0,0,.42);
  --card-shadow-hover:0 6px 20px rgba(0,0,0,.55),0 3px 12px rgba(0,0,0,.5);
  --chip-bg:color-mix(in srgb, var(--brand) 16%, var(--paper));
  --chip-ink:color-mix(in srgb, var(--brand) 60%, var(--ink));
  --accent-blue:#60a5fa;
  --accent-amber:#fbbf24;
  --accent-red:#f87171;
  --accent-grey:#9ca3af;
}

.control-bar,
.controls,
.header-controls{background:transparent;}

.controls-bar{
  background:transparent;
  box-shadow:none;
}

.ctrl-pill{
  display:inline-flex;
  align-items:center;
  gap:.5rem;
  height:36px;
  padding:0 .75rem;
  border-radius:9999px;
  border:1px solid var(--ctrl-pill-border);
  background:var(--ctrl-pill);
  color:var(--ctrl-fg);
  box-shadow:var(--ctrl-shadow);
  font:inherit;
  font-weight:600;
  letter-spacing:.1px;
  cursor:pointer;
  user-select:none;
  transition:background .2s ease, border-color .2s ease, color .2s ease, transform .06s ease;
}
.ctrl-pill:hover{background:var(--ctrl-hover);}
.ctrl-pill:active{transform:translateY(1px);}
.ctrl-pill:focus-visible{outline:2px solid var(--ctrl-ring);outline-offset:2px;}
.ctrl-pill:disabled{
  opacity:.6;
  cursor:not-allowed;
  box-shadow:none;
}

.switch-wrap{display:inline-flex;align-items:center;gap:.5rem;}
.switch{position:relative;width:56px;height:28px;border-radius:9999px;background:color-mix(in oklab,var(--ctrl-fg) 12%,transparent);border:1px solid var(--ctrl-pill-border);transition:background .2s ease,border-color .2s ease;}
.switch__thumb{position:absolute;top:3px;left:3px;width:22px;height:22px;border-radius:50%;background:var(--ctrl-bg);box-shadow:var(--ctrl-shadow);transition:left .2s ease,background .2s ease;}
[role="switch"][aria-checked="true"] .switch{background:color-mix(in oklab,var(--ctrl-on) 40%,transparent);border-color:color-mix(in oklab,var(--ctrl-on) 55%,var(--ctrl-pill-border));}
[role="switch"][aria-checked="true"] .switch__thumb{left:31px;background:var(--ctrl-bg);}
.switch-label{color:var(--ctrl-fg);font-weight:600;}

.btn-eye{position:relative;}
.btn-eye[aria-pressed="true"]{border-color:var(--ctrl-on);box-shadow:0 0 0 2px color-mix(in oklab,var(--ctrl-on) 25%,transparent);}
.btn-eye .icon{width:18px;height:18px;display:inline-flex;}
.btn-eye .icon svg{width:100%;height:100%;fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5;}
.btn-eye [data-eye="off"]{display:none;}
.btn-eye[aria-pressed="true"] [data-eye="on"]{display:none;}
.btn-eye[aria-pressed="true"] [data-eye="off"]{display:inline-flex;}

.icon{width:16px;height:16px;display:inline-block;fill:currentColor;}

body.dark{
  background:linear-gradient(180deg,
    var(--winter-night-start) 0%,
    var(--winter-night-mid) 58%,
    var(--winter-night-far) 100%
  );
  background-attachment:fixed;
  background-color:var(--winter-night-far);
}

body.dark::before{
  background:linear-gradient(180deg,
    var(--winter-night-start) 0%,
    var(--winter-night-mid) 58%,
    var(--winter-night-far) 100%
  );
  background-color:var(--winter-night-far);
}

body{font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";color:var(--ink);background:var(--bg);margin:0;font-size:13px;line-height:1.32;-webkit-print-color-adjust:exact;print-color-adjust:exact}

/* paint under sticky elements to avoid blue gap as things pin */
body::before{content:"";position:fixed;left:0;right:0;top:0;height:var(--ui-offset, var(--sticky-controls-offset,0px));background:var(--bg);pointer-events:none;z-index:180}
@media (max-width: 1248px){body::before{height:0}}

/* === GLOBAL WINTER FX LAYER === */
.fx-layer,
.fx-layer canvas,
.fx-layer div{
  position:fixed;
  inset:0;
  pointer-events:none;
}

.fx-layer{z-index:320;opacity:0;transition:opacity .6s ease;}

.fx-layer canvas{z-index:2;}
#snow-mid{z-index:3;}
#snow-near{z-index:4;}
.night-tint{z-index:0;}
.aurora-glow{z-index:1;}

.page,
.page-head,
main{position:relative;}

/* === Atmospheric Tint + Glow === */
.night-tint{
  background:radial-gradient(ellipse at center, rgba(8,20,40,0.42) 0%, rgba(2,6,15,0.9) 100%);
  mix-blend-mode:multiply;
  opacity:.48;
  transition:opacity 1s ease;
}

.aurora-glow{
  background:radial-gradient(800px 500px at 60% 0%, rgba(0,80,255,0.12), transparent 70%),
              radial-gradient(1000px 400px at 20% 0%, rgba(255,255,255,0.08), transparent 80%);
  animation:auroraWave 20s ease-in-out infinite alternate;
  opacity:.3;
}

@keyframes auroraWave{
  0%{background-position:60% 0%,20% 0%;}
  100%{background-position:40% 0%,10% -20%;}
}

@media (prefers-reduced-motion: reduce){
  .aurora-glow{animation:none;}
  body.winter h1.title{animation:none;}
}

.page{
  --page-pad-top:12px;
  --page-pad-inline:clamp(20px,4vw,36px);
  --page-pad-bottom:48px;
  padding:var(--page-pad-top) var(--page-pad-inline) var(--page-pad-bottom);
  box-sizing:border-box;
  max-width:clamp(960px,96vw,1680px);
  margin-inline:auto;
}

.page-head{display:flex;align-items:center;justify-content:space-between;padding-bottom:12px;margin-bottom:0;position:relative;z-index:350;gap:16px}
.page-head__title{display:flex;align-items:center;gap:12px;flex:1 1 auto;min-width:0;flex-wrap:wrap;position:relative}
.page-head__title .title{margin:0;flex:1 1 auto;min-width:0}
.page-head__title nav{margin-left:auto;display:flex;flex-wrap:wrap;gap:8px}
.page-head__title--with-badge{padding-right:var(--week-badge-space,188px)}
.page-head__title--with-badge .week-badge{position:absolute;top:50%;right:0;transform:translateY(-50%);margin:0;white-space:nowrap}
.week-badge{display:inline-flex;align-items:center;gap:6px;margin-left:0;font-size:12px;font-weight:700;padding:4px 10px;border:1px solid var(--grid);border-radius:999px;background:color-mix(in srgb,var(--als-blue) 10%,var(--paper));vertical-align:middle}
.week-badge[data-state="loading"]::before{content:"";width:10px;height:10px;border:2px solid currentColor;border-right-color:transparent;border-radius:50%;animation:weekBadgeSpin .75s linear infinite}
.week-badge[hidden]{display:none}
.week-picker .week-badge{margin-left:0}
@keyframes weekBadgeSpin{to{transform:rotate(360deg)}}
.title{font-size:28px;font-weight:800;margin:0;color:var(--ink)}
.logo{height:50px;margin-left:auto;display:block;flex-shrink:0}
.top-rule{height:2px;background:var(--als-blue);border-bottom:1px solid var(--als-blue-strong);margin:0;position:relative;z-index:320}
/* sticky controls block */
.sticky-top{position:sticky;top:0;z-index:300;background:color-mix(in srgb,var(--bg) 20%,transparent);backdrop-filter:blur(16px);padding:10px 0;margin:0;border-bottom:1px solid color-mix(in srgb,var(--border) 55%,transparent)}
.sticky-top__bar{display:flex;justify-content:flex-start;align-items:center;gap:8px;row-gap:8px;flex-wrap:wrap}
.sticky-content{transition:opacity .18s ease}
.sticky-top[data-collapsed="true"]{padding:6px 0}
.sticky-top[data-collapsed="true"] .sticky-content{display:none!important;opacity:0}
.sticky-top[data-collapsed="true"] .controls{display:none!important}
.sticky-top[data-collapsed="true"] .sticky-top__bar{gap:0}
.sticky-top[data-collapsed="true"] #hide-controls{margin-left:0}

.controls{display:flex;gap:10px;row-gap:8px;align-items:center;font-size:12px;flex-wrap:wrap}
.controls--primary{gap:8px;flex:1 1 auto}
.controls--primary>*{flex:0 0 auto}
.controls--secondary{margin-top:8px}
.controls input[type="file"],.controls textarea{font:inherit}
.controls--primary .legend-inline{margin-right:0}
.week-picker{gap:4px}
.controls-bar{
  background:transparent;
  border:0;
  box-shadow:none;
  padding:10px 0;
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}
.controls-bar>*{flex:0 0 auto}
.controls-bar .search-input{
  flex:1 1 320px;
  min-width:220px;
  max-width:min(720px,100%);
  order:-1;
  background:var(--input-bg);
  color:var(--input-fg);
  border:1px solid var(--input-bd);
  border-radius:999px;
  padding:8px 14px;
  font:inherit;
  font-weight:600;
  transition:border-color .18s ease,box-shadow .18s ease,background-color .18s ease;
}
.controls-bar .search-input::placeholder{color:color-mix(in srgb,var(--input-fg) 55%,transparent);font-weight:500}
.controls-bar .search-input:focus{outline:0;border-color:var(--input-bd-focus);box-shadow:0 0 0 3px color-mix(in oklab,var(--input-bd-focus) 30%,transparent)}
.controls-bar .filter-group{display:flex;align-items:center;gap:6px;font-weight:600;color:var(--ink);margin:0}
.controls-bar .filter-group label{color:var(--muted)}
.controls-bar .filter-group select,
.controls-bar select,
.controls-bar .input,
.controls-bar .search,
.controls-bar input[type="text"]{
  background:var(--input-bg);
  color:var(--input-fg);
  border:1px solid var(--input-bd);
  border-radius:10px;
  padding:8px 10px;
  font:inherit;
  transition:border-color .18s ease,box-shadow .18s ease,background-color .18s ease;
}
.controls-bar .filter-group select{min-width:0;cursor:pointer}
.controls-bar .filter-group select:focus,
.controls-bar select:focus,
.controls-bar .input:focus,
.controls-bar .search:focus,
.controls-bar input[type="text"]:focus{
  outline:0;
  border-color:var(--input-bd-focus);
  box-shadow:0 0 0 3px color-mix(in oklab,var(--input-bd-focus) 30%,transparent);
}
.controls-bar #weekPicker{font-weight:700;color:var(--ink)}
.controls-bar .week-picker{gap:6px}
.controls-bar .week-picker button{flex:0 0 auto}
.controls-bar #exportCsvBtn{margin-left:auto}
.sticky-top__bar>#hide-controls{margin-left:auto}

.filter-group{display:flex;align-items:center;gap:6px;font-weight:600;color:var(--ink)}

.mobile-sort__controls label{color:var(--muted);font-weight:600}
.mobile-sort__controls select,
.mobile-sort__controls input[type="text"]{
  background:var(--input-bg);
  color:var(--input-fg);
  border:1px solid var(--input-bd);
  border-radius:10px;
  padding:8px 10px;
  font:inherit;
  transition:border-color .18s ease,box-shadow .18s ease,background-color .18s ease;
}
.mobile-sort__controls select:focus,
.mobile-sort__controls input[type="text"]:focus{
  outline:0;
  border-color:var(--input-bd-focus);
  box-shadow:0 0 0 3px color-mix(in oklab,var(--input-bd-focus) 30%,transparent);
}

.btn{
  --pad-x:14px;
  --pad-y:8px;
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:var(--pad-y) var(--pad-x);
  border-radius:999px;
  font-weight:600;
  line-height:1;
  border:1px solid transparent;
  cursor:pointer;
  transition:transform .02s ease,background .15s ease,border-color .15s ease;
  color:var(--ink);
  background:var(--btn-ghost-bg);
}
.btn:active{transform:translateY(1px)}
.btn--primary{color:var(--btn-fg);background:var(--btn-bg);border-color:var(--btn-bg)}
.btn--primary:hover{background:var(--btn-bg-hover)}
.btn--outline{color:var(--btn-outline-fg);background:transparent;border-color:var(--btn-outline-bd)}
.btn--outline:hover{border-color:var(--btn-outline-fg)}
.btn--ghost{color:var(--btn-ghost-fg);background:var(--btn-ghost-bg)}
.btn--ghost:hover{background:var(--btn-ghost-bg-hover)}
.btn--icon{padding:8px;width:36px;height:36px;justify-content:center}
.btn--sm{--pad-x:10px;--pad-y:6px;font-size:12px}

.active-filter-chips{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:4px 0 12px;padding:0}
.active-filter-chips[hidden]{display:none}
.active-filter-chips::before{content:"Active filters";font-size:11px;font-weight:700;letter-spacing:.4px;color:var(--muted);margin-right:8px}
.filter-chip{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:999px;border:1px solid color-mix(in srgb,var(--surface-border) 60%,var(--grid));background:color-mix(in srgb,var(--surface-glass) 80%,transparent);color:var(--ink);font-weight:600;font-size:12px;cursor:pointer;max-width:100%;text-align:left;transition:background .2s ease,border-color .2s ease,color .2s ease;backdrop-filter:blur(8px)}
.filter-chip:hover{background:color-mix(in srgb,var(--surface-glass-strong) 86%,transparent);border-color:color-mix(in srgb,var(--surface-border) 70%,var(--als-blue))}
.filter-chip:focus-visible{outline:2px solid color-mix(in srgb,var(--als-blue) 65%,transparent);outline-offset:2px}
.filter-chip__label{display:inline-block;max-width:min(280px,100%);white-space:normal;word-break:break-word}
.filter-chip__icon{font-size:16px;line-height:1}

/* tabs */
.nav{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 0}
.nav .tab{padding:8px 12px;border:1px solid var(--grid);border-radius:999px;cursor:pointer;background:transparent;color:var(--ink);font-weight:700;box-shadow:none}
.nav .tab[aria-selected="true"]{background:color-mix(in srgb,var(--als-blue) 8%,var(--paper));border-color:var(--als-blue);box-shadow:0 0 0 2px color-mix(in srgb,var(--als-blue) 25%,transparent)}

/* KPI row sticks just below the controls */
.kpi-panels{min-height:72px;margin-bottom:0;position:sticky;top:var(--sticky-controls-offset,0px);z-index:260;background:color-mix(in srgb,var(--bg) 88%,transparent);backdrop-filter:blur(12px);padding:4px 0 0;border-bottom:1px solid var(--border)}
.dash-kpis[hidden]{display:none!important}
.kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px;margin:0}
.kpi-row{display:grid;grid-template-columns:repeat(5,minmax(140px,1fr));gap:12px;margin:12px 0}
.kpi{background:var(--paper);border:1px solid var(--border);border-radius:14px;box-shadow:var(--shadow);padding:14px 16px;color:var(--ink)}
.kpi .label{font-size:12px;color:var(--muted);letter-spacing:.2px}
.kpi .value{font-size:24px;font-weight:800;line-height:1.1;margin-top:4px}
.card{position:relative;background:var(--paper);border:1px solid var(--border);border-radius:14px;padding:14px 16px;box-shadow:var(--shadow);color:var(--ink)}
.card h3{margin:0 0 6px;font-size:12px;text-transform:uppercase;letter-spacing:.5px;color:var(--muted)}
.card .big{font-size:22px;font-weight:900}
.card::before{content:"";position:absolute;inset:-1px;border-radius:inherit;opacity:0;pointer-events:none;z-index:-1;}
.kpi-clickable{cursor:pointer;user-select:none;transition:box-shadow .18s ease,border-color .18s ease,background-color .18s ease}
.kpi-clickable:hover{box-shadow:0 0 0 2px color-mix(in srgb,var(--als-blue) 25%,transparent);border-color:var(--als-blue)}
.kpi-clickable[aria-pressed="true"]{background:color-mix(in srgb,var(--als-blue) 12%,var(--paper));border-color:var(--als-blue);box-shadow:0 0 0 2px color-mix(in srgb,var(--als-blue) 25%,transparent)}

/* === Winter Mode Styling === */
body.winter{
  --bg:#050b1d;
  --paper:rgba(15,25,45,0.55);
  --ink:#eaf1ff;
  --muted:#b6c3d8;
  --border:rgba(110,150,214,0.28);
  --grid:rgba(90,128,196,0.28);
  --zebra:rgba(12,22,40,0.55);
  --thead:rgba(54,94,168,0.78);
  --thead-text:#ecf4ff;
  --als-blue:#68a8ff;
  --als-blue-strong:#8cc7ff;
  --btn-outline-bd:rgba(120,170,232,0.35);
  --btn-ghost-bg-hover:rgba(104,168,255,0.18);
  --btn-bg:#68a8ff;
  --btn-bg-hover:#7cc2ff;
  --input-bg:rgba(10,20,36,0.55);
  --input-fg:#eaf1ff;
  --input-bd:rgba(120,170,232,0.35);
  --input-bd-focus:#68a8ff;
  --surface-border:rgba(120,170,232,0.4);
  text-shadow:0 0 6px rgba(11,103,194,.35);
  background:radial-gradient(circle at top,#03112c,#020914 75%);
}

body.winter .night-tint{opacity:.54;}

body.winter h1.title{animation:headerGlow 8s ease-in-out infinite;}

@keyframes headerGlow{
  0%,100%{text-shadow:0 0 6px rgba(100,180,255,0.2);}
  50%{text-shadow:0 0 12px rgba(120,200,255,0.5);}
}

body.winter .sticky-top,
body.winter .controls-bar,
body.winter .kpi,
body.winter .card,
body.winter .dash-empty,
body.winter .table-scroll,
body.winter .mobile-card,
body.winter .mobile-sort__controls,
body.winter .mobile-sort__toggle,
body.winter .active-filter-chips,
body.winter .filter-chip{
  backdrop-filter:blur(6px) saturate(120%);
  background-color:rgba(15,25,45,0.55);
  border-color:rgba(255,255,255,0.08);
  box-shadow:0 18px 32px rgba(6,12,24,0.42);
}

body.winter .table-scroll thead th{
  background:rgba(54,94,168,0.86);
  border-color:rgba(8,16,32,0.5);
}

body.winter .table-scroll tbody td{
  background:rgba(11,20,38,0.62);
  border-bottom-color:rgba(118,168,244,0.24);
}

body.winter .mobile-card,
body.winter .kpi{
  position:relative;
}

body.winter .card::before,
body.winter .mobile-card::before,
body.winter .kpi::before{
  opacity:.25;
  background:radial-gradient(circle at top,rgba(180,220,255,0.35),transparent 70%);
  filter:blur(0.5px);
}

body.winter .nav .tab[aria-selected="true"]{background:rgba(104,168,255,0.22);border-color:rgba(104,168,255,0.6);box-shadow:0 0 0 2px rgba(104,168,255,0.45);color:#f3f7ff;}
body.winter .nav .tab{color:var(--ink);border-color:rgba(118,168,244,0.32);background:rgba(9,18,34,0.45);}
body.winter .nav .tab:hover{border-color:rgba(104,168,255,0.7);}

body.winter .btn--primary{background:linear-gradient(130deg,rgba(64,134,232,0.9),rgba(98,180,255,0.9));border-color:rgba(104,168,255,0.9);}
body.winter .btn--primary:hover{background:linear-gradient(130deg,rgba(80,156,255,0.95),rgba(124,200,255,0.95));}

body.winter .btn--outline{color:#d6e8ff;border-color:rgba(120,170,232,0.6);}

body.winter .btn--ghost{color:#dcecff;}

body.winter .mobile-sort__toggle,
body.winter .mobile-sort__controls{color:#eaf1ff;}

body.winter .filter-chip{color:#eaf1ff;}

/* ===== TABLE WITH WORKING STICKY HEADER ===== */
table{
  width:100%;
  min-width:var(--table-min-width, 1100px);
  border-collapse:separate;
  border-spacing:0;
  table-layout:fixed;
}

/* JS will set max-height precisely; start with a conservative fallback */
.table-scroll{
  position: relative;
  overflow-y: auto;
  overflow-x: auto;
  max-height: 60vh; /* fallback only; overwritten by JS below */
}

.table-scroll thead{
  position: sticky;
  top: 0;             /* important in windowed-table mode */
  z-index: 2;
  background: var(--thead);
}

.table-scroll thead th{
  background: var(--thead);
  color: var(--thead-text);
  font-weight: 800;
  letter-spacing: 0.2px;
  padding: 10px 6px;
  border-top: 1px solid color-mix(in srgb, #000 25%, transparent);
  border-bottom: 1px solid color-mix(in srgb, #000 25%, transparent);
  text-align: left;
  white-space: nowrap;
}

.table-scroll thead th:first-child{
  padding-left: 14px;
}
tbody td{background:var(--zebra);border-bottom:1px solid var(--grid);padding:8px 6px;vertical-align:top;overflow-wrap:anywhere;word-break:break-word;hyphens:auto;line-height:1.35}
/* ADD: tidy up the ID column + gutter for the rail */
.table-scroll thead th[data-col="ID"],
.table-scroll td[data-col="ID"]{
  text-align:right;                 /* numbers line up neatly */
  font-weight:900;
  font-variant-numeric:tabular-nums;/* equal-width digits */
  white-space:nowrap;
  padding-right:12px;               /* space to the header divider */
  padding-left:18px;                /* gutter for the red rail */
}
/* --- Clear, obvious sort state on column headers --- */

/* Base arrow (hidden until sorted) */
.table-scroll thead th .sort-arrow{
  display:inline-block;
  width:0; height:0;
  margin-left:8px;
  opacity:0;
  transition:opacity .15s ease, transform .15s ease;
  /* triangle pointing up; we rotate for desc */
  border-left:5px solid transparent;
  border-right:5px solid transparent;
  border-top:7px solid currentColor;
}

/* When a column is sorted, darken the header and show the arrow */
.table-scroll thead th[data-sort]{
  /* Slightly darker than --thead */
  background: color-mix(in srgb, var(--thead) 88%, #000);
  /* Subtle underline highlight for the active column */
  box-shadow: inset 0 -2px 0 color-mix(in srgb, var(--thead-text) 40%, transparent);
  transition: background .15s ease, box-shadow .15s ease;
}

/* Ascending: arrow points up (default triangle) */
.table-scroll thead th[data-sort="asc"] .sort-arrow{
  opacity:1;
  transform: translateY(-1px);
}

/* Descending: rotate the triangle */
.table-scroll thead th[data-sort="desc"] .sort-arrow{
  opacity:1;
  transform: rotate(180deg) translateY(-1px);
}

/* Optional: hover/focus hint even before sorting */
.table-scroll thead th:hover,
.table-scroll thead th:focus{
  background: color-mix(in srgb, var(--thead) 92%, #000);
}
  /* ✅ Highlight DONE rows (green), similar to Priority tint + rail) */
/* Only apply when the row is NOT already marked as "Priority" */
.table-scroll tbody tr:not(.row-priority):has(td[data-col="Status"] .status-chip.done) > td{
  background: color-mix(in srgb, var(--done-tx) 12%, var(--paper));
}

/* add a green rail on the left, like the Priority rail */
.table-scroll tbody tr:not(.row-priority):has(td[data-col="Status"] .status-chip.done) > td:first-child{
  position: relative;
  z-index: 0;
}
.table-scroll tbody tr:not(.row-priority):has(td[data-col="Status"] .status-chip.done) > td:first-child::before{
  content: "";
  position: absolute;
  left: 6px;
  top: 6px;
  bottom: 6px;
  width: 3px;
  border-radius: 999px;
  background: var(--done-tx);
  box-shadow: 0 0 0 1px color-mix(in srgb, var(--done-tx) 28%, transparent);
  pointer-events: none;
  z-index: -1;
}

/* optional: slightly stronger tint in dark mode to stand out */
.dark .table-scroll tbody tr:not(.row-priority):has(td[data-col="Status"] .status-chip.done) > td{
  background: color-mix(in srgb, var(--done-tx) 18%, var(--zebra));
}
/* Mobile cards: give DONE cards a green accent so they pop */
.mobile-cards .mobile-card:has(.status-chip.done){
  border-color: color-mix(in srgb, var(--done-tx) 55%, var(--grid));
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--done-tx) 22%, transparent);
}
  /* ✅ DONE + PRIORITY rows:
   keep the red Priority rail, but add a green DONE tint to the row */
.table-scroll tbody tr.row-priority:has(td[data-col="Status"] .status-chip.done) > td{
  /* override the blue-ish priority background with a green-ish one */
  background: color-mix(in srgb, var(--done-tx) 12%, var(--paper));
}

/* Slightly stronger in dark mode so it stands out */
.dark .table-scroll tbody tr.row-priority:has(td[data-col="Status"] .status-chip.done) > td{
  background: color-mix(in srgb, var(--done-tx) 18%, var(--zebra));
}

/* row priority rail */
tr.row-priority>td:first-child{position:relative;z-index:0}
tr.row-priority>td:first-child::before{content:"";position:absolute;left:6px;top:6px;bottom:6px;width:3px;border-radius:999px;background:var(--priority-rail);box-shadow:0 0 0 1px color-mix(in srgb,var(--priority-rail) 28%,transparent);pointer-events:none;z-index:-1}
tr.row-priority>td{background:color-mix(in srgb,var(--als-blue) 6%,var(--paper))}
.dark tr.row-priority>td{background:color-mix(in srgb,var(--als-blue) 10%,var(--zebra))}

/* match column widths in cells via colgroup (your JS adds <colgroup>) */
.col-id{width:var(--col-id);min-width:var(--col-id);max-width:var(--col-id)} 
.col-title{width:var(--col-title);min-width:var(--col-title);max-width:var(--col-title)} 
.col-status{width:var(--col-status);min-width:var(--col-status);max-width:var(--col-status)}
.col-priority{width:var(--col-priority);min-width:var(--col-priority);max-width:var(--col-priority)} 
.col-createdby{width:var(--col-assigned);min-width:var(--col-assigned);max-width:var(--col-assigned)} 
.col-createdon{width:var(--col-created);min-width:var(--col-created);max-width:var(--col-created)}
.col-updated{width:var(--col-updated);min-width:var(--col-updated);max-width:var(--col-updated)} 
.col-completedon{width:var(--col-completed);min-width:var(--col-completed);max-width:var(--col-completed)} 
.col-location{width:var(--col-location);min-width:var(--col-location);max-width:var(--col-location)}
.col-asset{width:var(--col-asset);min-width:var(--col-asset);max-width:var(--col-asset)} 
.col-categories{width:auto!important}

/* Force table cells to match exactly */
tbody td{padding:8px 6px;box-sizing:border-box}

.id{font-weight:700}
.title-cell b{display:block;font-weight:800}

/* chips */
.chip-cat{display:inline-flex;align-items:center;border-radius:999px;padding:4px 10px;border:1px solid currentColor;background:transparent;margin:2px 6px 2px 0;font-weight:600;font-size:12px;line-height:1;white-space:nowrap}
.table-scroll td[data-col="Categories"]{white-space:normal;min-width:140px;width:1%}
.table-scroll td[data-col="Categories"] .chip-stack{display:flex;flex-wrap:wrap;gap:4px 6px;align-items:center}
.table-scroll td[data-col="Categories"] .chip-cat{margin:0;white-space:nowrap;font-size:11px;padding:3px 8px}

/* status + age chips (unchanged visuals) */
.status-chip{--ring:color-mix(in srgb,currentColor 40%,transparent);--bg:color-mix(in srgb,currentColor 18%,transparent);display:inline-flex;align-items:center;gap:6px;padding:3px 10px;border-radius:999px;font-weight:700;font-size:12px;line-height:1;border:1px solid var(--ring);background:var(--bg);color:currentColor}
.status-chip::before{content:"";width:14px;height:14px;display:inline-block;background:currentColor;mask:var(--icon) no-repeat center/14px 14px;-webkit-mask:var(--icon) no-repeat center/14px 14px}
.status-chip.open{--icon:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><circle cx='8' cy='8' r='5.5' fill='none' stroke='black' stroke-width='2'/></svg>");color:var(--open-tx);border-color:color-mix(in srgb,var(--open-tx) 55%,transparent);background:color-mix(in srgb,var(--open-tx) 12%,var(--paper));box-shadow:none;padding:4px 12px}
.status-chip.open::before{background:var(--open-tx)}
.status-chip.in-progress{color:var(--open-tx);--icon:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><path fill='black' fill-rule='evenodd' d='M8 1a7 7 0 1 1 0 14A7 7 0 0 1 8 1zm0 2a5 5 0 1 0 0 10A5 5 0 0 0 8 3z'/><rect x='7.25' y='3' width='1.5' height='5' rx='0.75' fill='black'/><rect x='7.25' y='8' width='4.5' height='1.5' rx='0.75' fill='black'/></svg>")}
.status-chip.on-hold{color:var(--hold-tx);--icon:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect x='3' y='2' width='4' height='12' rx='1' fill='black'/><rect x='9' y='2' width='4' height='12' rx='1' fill='black'/></svg>")}
.status-chip.done{color:var(--done-tx);--icon:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><path fill='black' d='M6.6 12.2 2.9 8.5l1.4-1.4 2.3 2.3 4.9-4.9 1.4 1.4-6.3 6.3z'/></svg>");--bg:color-mix(in srgb,var(--done-tx) 18%,transparent);--ring:color-mix(in srgb,var(--done-tx) 40%,transparent)}
@supports not(mask:url("")){.status-chip::before{mask:none;-webkit-mask:none;background:none;width:auto;margin-right:2px;content:var(--glyph,"•")}.status-chip.open{--glyph:"○"}.status-chip.in-progress{--glyph:"⏳"}.status-chip.on-hold{--glyph:"⏸"}.status-chip.done{--glyph:"✓"}}

.age-chip{--ring:color-mix(in srgb,currentColor 50%,transparent);--bg:color-mix(in srgb,currentColor 26%,transparent);display:inline-flex;align-items:center;padding:4px 9px;border-radius:999px;font-weight:800;font-size:12.5px;line-height:1;border:1px solid var(--ring);background:var(--bg);font-variant-numeric:tabular-nums}
.age-chip.frozen{position:relative;padding-right:22px;border-style:dashed;background:var(--bg);cursor:help}
.age-chip.frozen::after{content:"❄";font-size:12px;line-height:1;position:absolute;right:6px;top:50%;transform:translateY(-50%);opacity:.9}
.age-chip.age-fresh{color:#10b981}
.age-chip.age-stale{color:#b45309}
.age-chip.age-old{color:#dc2626;--bg:color-mix(in srgb,currentColor 32%,transparent)}
.age-chip.age-ancient{color:#991b1b;--bg:color-mix(in srgb,currentColor 38%,transparent)}
.dark .age-chip{text-shadow:0 1px 0 rgba(0,0,0,.35);box-shadow:0 0 0 1px color-mix(in srgb,currentColor 30%,transparent)}
.age-chip:focus-visible{outline:2px solid color-mix(in srgb,currentColor 55%,transparent);outline-offset:2px}

/* mobile cards */
.mobile-cards{display:none}
.mobile-card{border:1px solid var(--grid);border-radius:14px;padding:12px;background:var(--paper);display:grid;grid-template-columns:1fr auto;gap:8px 12px}
.mobile-card+.mobile-card{margin-top:10px}
.mobile-card__title{font-weight:800;line-height:1.3}
.mobile-card__id{font-weight:900;opacity:.7}
.mobile-card__meta{grid-column:1/-1;display:flex;flex-wrap:wrap;gap:8px;font-size:12px;color:var(--muted)}
.mobile-card__row{grid-column:1/-1;display:flex;gap:8px;row-gap:4px;flex-wrap:wrap;align-items:flex-start}
.mobile-card__meta-row{gap:12px}
.mobile-card__field{display:flex;align-items:center;gap:6px}
.mobile-card__field strong{font-weight:600}
.mobile-sort{display:none}
.mobile-sort__toggle{display:flex;flex-direction:column;align-items:flex-start;gap:4px;padding:10px 14px 10px 12px;border-radius:12px;border:1px solid color-mix(in srgb,var(--als-blue) 12%,var(--grid));background:color-mix(in srgb,var(--als-blue) 4%,var(--paper));color:var(--ink);font:inherit;font-weight:700;cursor:pointer;position:relative;transition:border-color .18s ease,box-shadow .18s ease,background-color .18s ease,color .18s ease}
.mobile-sort__toggle::after{content:"";position:absolute;right:14px;top:50%;transform:translateY(-50%);width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:7px solid currentColor;transition:transform .18s ease}
.mobile-sort[data-open="true"] .mobile-sort__toggle::after{transform:translateY(-50%) rotate(180deg)}
.mobile-sort__toggle:focus-visible{outline:2px solid color-mix(in srgb,var(--als-blue) 55%,transparent);outline-offset:3px;box-shadow:0 0 0 4px color-mix(in srgb,var(--als-blue) 14%,transparent)}
.mobile-sort[data-has-sort="true"] .mobile-sort__toggle{border-color:color-mix(in srgb,var(--als-blue) 40%,var(--grid));background:color-mix(in srgb,var(--als-blue) 16%,var(--paper));box-shadow:0 8px 18px color-mix(in srgb,var(--als-blue) 18%,transparent);color:color-mix(in srgb,var(--als-blue) 75%,var(--ink))}
.mobile-sort__toggle-label{font-size:12px;letter-spacing:.4px;text-transform:uppercase;color:color-mix(in srgb,var(--muted) 88%,var(--ink));font-weight:700}
.mobile-sort__summary{font-size:12px;font-weight:600;color:var(--muted)}
.mobile-sort[data-has-sort="true"] .mobile-sort__summary{color:color-mix(in srgb,var(--als-blue) 65%,var(--ink))}
.mobile-sort__controls{display:flex;flex-direction:column;gap:10px;width:100%;padding-top:8px;margin-top:4px;border-top:1px solid color-mix(in srgb,var(--als-blue) 14%,var(--grid))}
.mobile-sort__controls[hidden]{display:none!important}
.mobile-sort__label{font-size:11px;font-weight:700;letter-spacing:.4px;color:var(--muted);text-transform:uppercase}
.mobile-sort__select{font:inherit;font-weight:600;padding:8px 12px;border-radius:10px;border:1px solid var(--input-bd);background:var(--input-bg);color:var(--input-fg);min-width:0;flex:1 1 220px;cursor:pointer;transition:border-color .18s ease,box-shadow .18s ease,background-color .18s ease}
.mobile-sort__select:focus-visible{outline:none;border-color:var(--input-bd-focus);box-shadow:0 0 0 3px color-mix(in oklab,var(--input-bd-focus) 30%,transparent)}
.mobile-sort__direction{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border-radius:999px;border:1px solid var(--btn-outline-bd);background:transparent;color:var(--btn-outline-fg);font-weight:600;cursor:pointer;transition:transform .02s ease,background .15s ease,border-color .15s ease,box-shadow .15s ease}
.mobile-sort__direction:hover{border-color:var(--btn-outline-fg);background:var(--btn-ghost-bg-hover)}
.mobile-sort__direction:focus-visible{outline:0;border-color:var(--input-bd-focus);box-shadow:0 0 0 3px color-mix(in oklab,var(--input-bd-focus) 30%,transparent)}
.mobile-sort__direction::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:7px solid currentColor;transition:transform .18s ease}
.mobile-sort__direction[data-direction="desc"]::after{transform:rotate(180deg)}
.mobile-sort__direction[disabled]{opacity:.45;cursor:not-allowed;box-shadow:none;background:color-mix(in srgb,var(--als-blue) 4%,var(--paper));color:color-mix(in srgb,var(--als-blue) 55%,var(--muted));border-color:color-mix(in srgb,var(--als-blue) 35%,var(--grid))}
.mobile-card .status-chip{font-size:12px}
.mobile-card .chip-cat{padding:3px 8px;font-size:11px;margin:2px 4px 4px 0}
@media(max-width:1248px){
  .dash-table .table-scroll{display:none}
  .mobile-cards{display:block}
  .page{--page-pad-inline:clamp(16px,6vw,24px)}
  .columns-bar{display:none} /* hide static bar on small screens */
  .mobile-sort{display:flex;flex-direction:column;gap:0;margin:12px 0 16px;padding:12px;border:1px solid var(--grid);border-radius:14px;background:color-mix(in srgb,var(--als-blue) 10%,var(--paper));box-shadow:0 10px 24px rgba(11,103,194,.08)}
  .mobile-sort__controls{flex-direction:row;flex-wrap:wrap;align-items:center;gap:10px;row-gap:8px}
  .mobile-sort__label{flex:1 1 100%;margin:0}
}

body.force-mobile .dash-table .table-scroll{display:none!important}
body.force-mobile .mobile-cards{display:block!important}
body.force-mobile .page{--page-pad-top:16px;--page-pad-inline:clamp(16px,6vw,24px);--page-pad-bottom:40px}
body.force-mobile .columns-bar{display:none!important}
body.force-mobile .mobile-sort{display:flex!important;flex-direction:column;gap:0;margin:12px 0 16px;padding:12px;border:1px solid var(--grid);border-radius:14px;background:color-mix(in srgb,var(--als-blue) 10%,var(--paper));box-shadow:0 10px 24px rgba(11,103,194,.08)}
body.force-mobile .mobile-sort__controls{flex-direction:row;flex-wrap:wrap;align-items:center;gap:10px;row-gap:8px}
body.force-mobile .mobile-sort__label{flex:1 1 100%;margin:0}

body.force-desktop .dash-table .table-scroll{display:block!important}
body.force-desktop .mobile-cards{display:none!important}
body.force-desktop .mobile-sort{display:none!important}

/* Legend popover – no hover gap, opens on hover or click */
.legend-popover{
  position:relative;
  /* create a safe hover “bridge” so the cursor never leaves the container */
  padding-bottom:10px; /* buffer below the button */
}
.legend-popover__panel{
  position:absolute;
  right:0;
  top:100%;                 /* removes the gap that caused flicker */
  margin-top:6px;           /* visual spacing, without breaking hover */
  width:min(360px,86vw);
  max-height:70vh;
  overflow:auto;
  background:transparent;
  color:var(--ink);
  border:1px solid var(--grid);
  border-radius:12px;
  padding:12px;
  box-shadow:0 12px 30px rgba(0,0,0,.18);
  opacity:0;
  transform:translateY(-4px);
  pointer-events:none;
  transition:opacity .15s ease,transform .15s ease;
  z-index:600;              /* a touch higher to sit above sticky UI */
}
.legend-popover__panel::before{
  content:"";
  position:absolute;
  top:-6px;
  right:24px;
  width:12px; height:12px;
  transform:rotate(45deg);
  background:transparent;
  border-left:1px solid var(--grid);
  border-top:1px solid var(--grid);
}
/* show rules */
.legend-popover:hover .legend-popover__panel,
.legend-popover:focus-within .legend-popover__panel,
.legend-popover.is-open .legend-popover__panel{
  opacity:1;
  transform:none;
  pointer-events:auto;
}

.legend{border:1px solid var(--grid);border-radius:12px;background:transparent;padding:12px;margin:8px 0 12px}
.legend__title{margin:0 0 8px;font-size:11px;text-transform:uppercase;letter-spacing:.4px;color:var(--muted)}
.legend__list{list-style:none;margin:0;padding:0;display:grid;grid-template-columns:auto 1fr;gap:8px 10px}
.legend__sample{display:contents}
.legend__list>.legend__sample>:first-child{display:inline-flex;align-items:center;gap:6px;min-height:22px}
.legend__rail{width:6px;height:16px;border-radius:999px;background:var(--priority-rail);box-shadow:0 0 0 1px color-mix(in srgb,var(--priority-rail) 28%,transparent)}
.legend__kpi{display:inline-block;padding:4px 8px;border:1px solid var(--grid);border-radius:10px;font-weight:800;font-size:12px;background:color-mix(in srgb,var(--als-blue) 8%,var(--paper));color:var(--ink)}
.legend--full{display:none}
@media print{.legend--full{display:block}}

.dash{display:none}
.dash[data-active="true"]{display:block}
.visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

/* responsive layout tweaks */
@media(min-width:1248px){table{table-layout:fixed}}
@media(max-width:1248px){.page{--page-pad-top:16px;--page-pad-inline:clamp(16px,6vw,24px);--page-pad-bottom:40px}}
@media(max-width:884px){
  .page{--page-pad-top:16px;--page-pad-inline:16px;--page-pad-bottom:28px}
  .page-head{gap:12px}
  .page-head__title{gap:10px}
  .page-head__title--with-badge{padding-right:0}
  .page-head__title--with-badge .week-badge{position:static;transform:none;margin-top:8px}
  .title{font-size:24px}
  .logo{height:40px}
  .controls{column-gap:10px;row-gap:8px}
  .controls textarea{width:100%;min-width:0}
}

@media print{
  @page{size:A4 landscape;margin:10mm}
  body{font-size:11.5px}
  thead{display:table-header-group}
  table{width:100%!important;table-layout:fixed;border-collapse:collapse}
  th,td{box-sizing:border-box;overflow-wrap:anywhere;word-break:break-word;hyphens:auto}
  thead th{position:static}
  .title-cell,.col-categories{break-inside:avoid}
  html{-webkit-print-color-adjust:exact}
  .controls,.columns-bar{display:none!important}
  .active-filter-chips{display:none!important}
}

@media print{
  html, body{ overflow:visible; }
  .table-scroll{ max-height:none; overflow:visible; }
}

/* ADD THIS NEW MOBILE OVERRIDE */
@media (max-width:1248px){
  html, body{ overflow:auto; }
  .table-scroll{ max-height:none; }
}
/* Legend button lives in the right-hand controls row */
.controls { align-items: center; }

/* Popover: always render above sticky elements and align to button’s right */
.legend-popover{
  position: relative;
  z-index: 1100;          /* above sticky bars */
  padding-bottom: 8px;    /* hover bridge to the panel */
}
.legend-popover__panel{
  position: absolute;
  right: 0;               /* align panel’s right edge with the button */
  top: 100%;              /* sit just below the button */
  margin-top: 6px;
  width: min(360px, 86vw);
  max-height: 70vh;
  overflow: auto;
  background: transparent;
  color: var(--ink);
  border: 1px solid var(--grid);
  border-radius: 12px;
  padding: 12px;
  box-shadow: 0 12px 30px rgba(0,0,0,.18);
  opacity: 0;
  transform: translateY(-4px);
  pointer-events: none;
  transition: opacity .15s ease, transform .15s ease;
  z-index: 1101;
}
.legend-popover__panel::before{
  content: "";
  position: absolute;
  top: -6px;
  right: 24px;
  width: 12px; height: 12px;
  transform: rotate(45deg);
  background: transparent;
  border-left: 1px solid var(--grid);
  border-top: 1px solid var(--grid);
}

/* show on hover, keyboard focus, or when JS toggles .is-open */
.legend-popover:hover .legend-popover__panel,
.legend-popover:focus-within .legend-popover__panel,
.legend-popover.is-open .legend-popover__panel{
  opacity: 1;
  transform: none;
  pointer-events: auto;
}
/* Inline legend button + hover panel (no JS required) */
.legend-inline{ position:relative; display:inline-block; margin-right:8px; }
.legend-inline__btn{ font-weight:800; }
.legend-inline__panel{
  position:absolute;
  left:0;                          /* shows under the button at the left */
  top:calc(100% + 8px);
  width:min(420px, 92vw);
  max-height:70vh;
  overflow:auto;
  background:transparent;
  color:var(--ink);
  border:1px solid var(--grid);
  border-radius:12px;
  padding:10px;
  box-shadow:0 12px 30px rgba(0,0,0,.18);
  opacity:0;
  transform:translateY(-4px);
  pointer-events:none;
  transition:opacity .15s ease, transform .15s ease;
  z-index:600;                     /* above sticky bars */
}
.legend-inline__panel::before{
  content:"";
  position:absolute;
  top:-6px; left:16px;
  width:12px; height:12px;
  transform:rotate(45deg);
  background:transparent;
  border-left:1px solid var(--grid);
  border-top:1px solid var(--grid);
}
.legend-inline:hover .legend-inline__panel,
.legend-inline:focus-within .legend-inline__panel{
  opacity:1; transform:none; pointer-events:auto;
}

/* --- Plan for Next Week overlay --- */
.plan-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
  background:color-mix(in srgb, var(--ink) 45%, transparent);
  backdrop-filter:blur(3px);
  z-index:1100;
}
.plan-overlay[hidden]{
  display:none;
}
.plan-dialog{
  width:min(1120px, 96vw);
  max-height:90vh;
  background:var(--paper);
  color:var(--ink);
  border-radius:18px;
  box-shadow:0 18px 42px rgba(15,21,42,.35);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  border:1px solid var(--grid);
}
.plan-dialog__header{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:20px 24px 16px;
  border-bottom:1px solid var(--grid);
}
.plan-dialog__title{
  font-size:1.35rem;
  font-weight:700;
  margin:0;
}
.plan-dialog__actions{
  display:flex;
  align-items:center;
  gap:8px;
}
.plan-dialog__actions .btn{
  white-space:nowrap;
}
.plan-status{
  padding:10px 24px;
  font-size:.92rem;
  color:var(--muted);
  border-bottom:1px solid var(--grid);
}
.plan-status[data-state="error"]{
  color:#b91c1c;
}
.plan-status[data-state="loading"]{
  color:var(--ink);
}
.plan-scroll{
  flex:1 1 auto;
  overflow:auto;
  padding:0 24px 24px;
}
.plan-table{
  width:100%;
  border-collapse:separate;
  border-spacing:0;
  min-width:780px;
}
.plan-table thead th{
  position:sticky;
  top:0;
  background:color-mix(in srgb, var(--paper) 90%, var(--bg));
  z-index:1;
}
.plan-table th,
.plan-table td{
  border:1px solid var(--grid);
  padding:14px 16px;
  vertical-align:top;
  background:var(--paper);
}
#plan-next-week .plan-table td{
  background:var(--paper);
}
#plan-next-week .plan-table tbody tr:nth-child(odd) td{
  background:var(--paper);
}
#plan-next-week .plan-table th,
#plan-next-week .plan-table td{
  padding:10px 12px;
}
.plan-table th[scope="row"]{
  background:color-mix(in srgb, var(--paper) 92%, var(--bg));
  font-weight:600;
  width:164px;
}
.plan-table tbody tr:nth-child(odd) td{
  background:color-mix(in srgb, var(--paper) 96%, var(--bg));
}
.task-card{
  position:relative;
  display:flex;
  flex-direction:column;
  gap:8px;
  padding:12px 16px 12px 20px;
  min-height:86px;
  border-radius:8px;
  border:1px solid var(--card-border, color-mix(in srgb, var(--grid) 70%, transparent));
  background:var(--card-bg, color-mix(in srgb, var(--paper) 96%, var(--bg)));
  box-shadow:var(--card-shadow-rest, var(--shadow));
  color:var(--ink);
  line-height:1.4;
  transition:box-shadow .18s ease, border-color .18s ease, transform .18s ease;
  word-break:break-word;
  overflow-wrap:anywhere;
  outline:0;
}
.task-card::before{
  content:"";
  position:absolute;
  left:0;
  top:12px;
  bottom:12px;
  width:4px;
  border-radius:999px;
  background:var(--accent-blue, var(--brand));
}
.task-card[data-variant="hold"]::before{
  background:var(--accent-amber, #f59e0b);
}
.task-card[data-variant="critical"]::before{
  background:var(--accent-red, #ef4444);
}
.task-card[data-variant="note"]{
  background:color-mix(in srgb, var(--card-bg, var(--paper)) 70%, var(--bg));
  color:color-mix(in srgb, var(--muted) 75%, var(--ink));
}
.task-card[data-variant="note"]::before{
  background:var(--accent-grey, var(--muted));
}
.task-card + .task-card{
  margin-top:12px;
}
.task-card:focus-visible{
  box-shadow:var(--card-shadow-hover, 0 6px 18px rgba(15,23,42,.16));
  outline:2px solid color-mix(in srgb, var(--brand) 55%, transparent);
  outline-offset:2px;
}
.task-card:hover{
  box-shadow:var(--card-shadow-hover, 0 6px 18px rgba(15,23,42,.16));
  border-color:color-mix(in srgb, var(--card-border, var(--border)) 70%, var(--brand) 30%);
}
.task-card.is-dragging,
.task-card[data-dragging="true"]{
  box-shadow:none;
  border-style:dashed;
  border-color:color-mix(in srgb, var(--card-border, var(--border)) 80%, transparent);
}
.task-card__chip-row{
  display:flex;
  align-items:center;
  gap:8px;
  margin:4px 0 0;
  min-height:0;
}
.task-card__chip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:2px 10px;
  border-radius:999px;
  background:var(--chip-bg, color-mix(in srgb, var(--brand) 12%, var(--card-bg, var(--paper))));
  color:var(--chip-ink, color-mix(in srgb, var(--brand) 35%, var(--ink)));
  font-size:12px;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:.04em;
}
.task-card__body{
  display:flex;
  flex-direction:column;
  gap:6px;
  min-height:0;
}
.task-card__title{
  font-size:14.5px;
  font-weight:600;
  line-height:1.4;
  color:var(--ink);
  display:-webkit-box;
  -webkit-line-clamp:3;
  -webkit-box-orient:vertical;
  overflow:hidden;
  text-overflow:ellipsis;
}
.task-card__suffix{
  color:var(--ink-muted, var(--muted));
  font-weight:500;
}
.task-card__meta,
.task-card__note{
  font-size:13px;
  color:var(--ink-muted, var(--muted));
}
.task-card__note{
  margin-top:2px;
}
.task-card__text{
  font-size:13px;
  color:var(--ink);
}
.plan-empty{
  text-align:center;
  color:var(--muted);
  font-style:italic;
}
@media (max-width: 860px){
  .plan-dialog{
    width:96vw;
  }
  .plan-scroll{
    padding:0 16px 16px;
  }
  .plan-dialog__header{
    padding:16px 16px 12px;
  }
  .plan-status{
    padding:8px 16px;
  }
  .plan-table{
    min-width:640px;
  }
}

/* Theme the legend overlays without changing the transparent controls bar */
.legend-popover__panel,
.legend-inline__panel{
  background-color: var(--paper);
}
.legend-popover__panel::before,
.legend-inline__panel::before{
  background-color: var(--paper);
}

/* Keep the print legend visible on hardcopy only (optional) */
.legend--full{ display:none; }
@media print{ .legend--full{ display:block; } }

</style>
</head>
<body class="light" data-plan-gid="">
  <!-- ❄️ Winter visual effects (hidden until Winter Plan is active) -->
  <div class="fx-layer" id="fx-layer" hidden>
    <canvas id="snow-far" aria-hidden="true"></canvas>
    <canvas id="snow-mid" aria-hidden="true"></canvas>
    <canvas id="snow-near" aria-hidden="true"></canvas>
    <div class="night-tint" aria-hidden="true"></div>
    <div class="aurora-glow" aria-hidden="true"></div>
  </div>
  <div class="page">
    <header class="page-head">
      <div class="page-head__title page-head__title--with-badge">
        <h1 class="title">Work Orders Dashboard</h1>
        <span class="week-badge" id="week-badge" aria-live="polite" data-state="loading" hidden>Loading…</span>
        <nav class="nav" aria-label="Dashboard sections">
          <a class="tab" aria-selected="true" href="index.html">Work Orders</a>
          <a class="tab" href="facilities.html">Facilities</a>
          <a class="tab" href="pssr.html">PSSR Inspections</a>
        </nav>
      </div>
      <img src="LOGOlesswhitespace.png" alt="Aberdeen Laundry Services logo" class="logo" />
    </header>

    <div class="top-rule" aria-hidden="true"></div>

    <main>

      <div class="sticky-top" data-collapsed="false">
        <div class="sticky-top__bar">
        <div class="controls controls--primary controls-bar" id="controls-bar" role="group" aria-label="Dashboard controls">
            <input id="globalSearch" class="search-input" type="search" placeholder="Search work orders…" aria-label="Search work orders" />
            <div class="legend-inline">
              <button type="button" class="btn btn--ghost btn--sm legend-inline__btn">Legend</button>
              <div class="legend-inline__panel" role="dialog" aria-modal="false" aria-label="Legend">
                <div class="legend">
                  <p class="legend__title">How to read this dashboard</p>
                  <ul class="legend__list">
                    <li class="legend__sample">
                      <span><span class="legend__rail"></span> Priority</span>
                      <span>Rows with the “Priority” category show a red rail and a subtle background tint.</span>
                    </li>

                    <li class="legend__sample">
                      <span><span class="status-chip done">Done</span></span>
                      <span>Completed work orders are lightly tinted green to stand out.</span>
                    </li>

                    <li class="legend__sample">
                      <span>
                        <span class="legend__rail"></span>
                        <span class="status-chip done" style="margin-left:6px">Done</span>
                      </span>
                      <span><strong>Done + Priority</strong>: keeps the red rail (Priority) and adds the green DONE tint.</span>
                    </li>

                    <li class="legend__sample">
                      <span><span class="chip-cat">Category</span></span>
                      <span>Category chips map directly to the sheet values.</span>
                    </li>

                    <li class="legend__sample">
                      <span><span class="age-chip age-old">14d</span></span>
                      <span>Age shows how long the order has been active. Snowflake indicates a frozen winter task.</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="filter-group week-picker">
              <button id="weekPrev" class="btn btn--outline btn--sm" type="button" data-week-nav="prev" aria-label="View previous dates">‹ Prev</button>
              <div id="weekPicker" aria-live="polite"></div>
              <button id="weekNext" class="btn btn--pill" type="button" data-week-nav="next" aria-label="View next dates">Next ›</button>
              <span class="week-badge" id="week-badge" aria-live="polite" hidden>Loading…</span>
            </div>

            <div class="filter-group">
              <label for="statusFilter">Status</label>
              <select id="statusFilter">
                <option value="">All statuses</option>
                <option value="Not: Done">Exclude Done</option>
                <option value="Open">Open</option>
                <option value="In Progress">In Progress</option>
                <option value="On Hold">On Hold</option>
                <option value="Done">Done</option>
              </select>
            </div>

            <button id="refreshBtn" class="btn btn--outline" type="button">Refresh data</button>
            <button id="exportCsvBtn" class="btn btn--primary" type="button" disabled>Export CSV</button>
            <button id="planNextWeekBtn" class="btn btn--ghost" type="button">Plan for Next Week</button>
            <button class="ctrl-pill switch-wrap" id="layout-toggle" type="button" role="switch" aria-checked="false" aria-label="Switch to mobile view">
              <span class="switch" aria-hidden="true"><span class="switch__thumb"></span></span>
              <span class="switch-label">Auto</span>
            </button>
            <button class="ctrl-pill switch-wrap" id="dark-toggle" type="button" role="switch" aria-checked="false" aria-label="Toggle dark theme">
              <span class="switch" aria-hidden="true"><span class="switch__thumb"></span></span>
              <span class="switch-label">Dark</span>
            </button>
          </div>
          <button class="ctrl-pill btn-eye" id="hide-controls" type="button" aria-pressed="false" aria-expanded="true" data-controls="controls-bar">
            <span class="icon" data-eye="on" aria-hidden="true">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12Z"></path>
                <circle cx="12" cy="12" r="3"></circle>
              </svg>
            </span>
            <span class="icon" data-eye="off" aria-hidden="true">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M17.94 17.94A10.94 10.94 0 0 1 12 20c-7 0-11-8-11-8a21.8 21.8 0 0 1 5.06-6.94"></path>
                <path d="M9.9 4.24A11 11 0 0 1 12 4c7 0 11 8 11 8a21.8 21.8 0 0 1-4.87 6.82"></path>
                <path d="M1 1l22 22"></path>
              </svg>
            </span>
            <span class="label">Hide controls</span>
          </button>
        </div>
        <div class="sticky-content" data-controls-panel>
          <div id="activeFilterChips" class="active-filter-chips" hidden></div>

          <nav class="nav" role="tablist" aria-label="Dashboard views">
            <button class="tab" type="button" role="tab" aria-selected="true" aria-controls="dash-all">All sites</button>
            <button class="tab" type="button" role="tab" aria-selected="false" aria-controls="dash-ek">East Kilbride</button>
            <button class="tab" type="button" role="tab" aria-selected="false" aria-controls="dash-mm">Mugiemoss</button>
            <button class="tab" type="button" role="tab" aria-selected="false" aria-controls="dash-keith">Keith</button>
            <button class="tab" type="button" role="tab" aria-selected="false" aria-controls="dash-by">Byron</button>
            <button class="tab" type="button" role="tab" aria-selected="false" aria-controls="dash-winter">Winter Plan</button>
          </nav>
        </div>
      </div>

      <div class="kpi-panels">
        <section class="dash-kpis" data-site="all"></section>
        <section class="dash-kpis" data-site="ek" hidden></section>
        <section class="dash-kpis" data-site="mm" hidden></section>
        <section class="dash-kpis" data-site="keith" hidden></section>
        <section class="dash-kpis" data-site="by" hidden></section>
        <section class="dash-kpis" data-site="winter" hidden></section>
      </div>

<section class="dashboards">
  <section id="dash-all" class="dash dash-table" data-site="all" data-active="true"></section>
  <section id="dash-ek" class="dash dash-table" data-site="ek" hidden></section>
  <section id="dash-mm" class="dash dash-table" data-site="mm" hidden></section>
  <section id="dash-keith" class="dash dash-table" data-site="keith" hidden></section>
  <section id="dash-by" class="dash dash-table" data-site="by" hidden></section>
  <section id="dash-winter" class="dash dash-table" data-site="winter" hidden></section>
</section>
    </main>
  </div>
  <div id="planNextWeekOverlay" class="plan-overlay" hidden aria-hidden="true">
    <div class="plan-dialog" id="planNextWeekDialog" role="dialog" aria-modal="true" aria-labelledby="planNextWeekTitle" tabindex="-1">
      <header class="plan-dialog__header">
        <h2 class="plan-dialog__title" id="planNextWeekTitle">Plan for Next Week</h2>
        <div class="plan-dialog__actions">
          <button id="planNextWeekRefresh" class="btn btn--ghost btn--sm" type="button">Refresh</button>
          <button id="planNextWeekClose" class="btn btn--ghost btn--sm" type="button">Close</button>
        </div>
      </header>
      <div id="planNextWeekStatus" class="plan-status" role="status" aria-live="polite"></div>
      <div class="plan-scroll">
        <table class="plan-table" id="planNextWeekTable" aria-describedby="planNextWeekStatus"></table>
      </div>
    </div>
  </div>
  <div id="loadingOverlay" style=" position:fixed; inset:0; display:none; place-items:center; background:color-mix(in srgb, var(--paper) 70%, transparent); z-index:9999;">
    <div style="padding:10px 14px;border:1px solid var(--grid);border-radius:10px;background:var(--paper);font-weight:800">
      Loading…
    </div>
  </div>
  <style>
  /* Integration notes:
     1) Paste this just before </body>.
     2) Winter Plan tab → Dark palette + night sky + snow (medium); other tabs use the saved theme.
     3) On Winter Plan the Light/Dark toggle only records preference (visual stays dark).
     4) Leaving Winter Plan reapplies the saved theme and toggles overlays automatically.
     5) APIs: WinterOverlay.{setDensity,refresh,destroy}, ChristmasLights.{enable,disable,refresh}.
  */
  #christmasLights{
    position:fixed;
    inset:0;
    pointer-events:none;
    display:none;
    z-index:9999;
    isolation:isolate;
  }
  #christmasLights .lights-strand{
    position:absolute;
    top:0;
    left:0;
    right:0;
    height:120px;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    padding:18px 36px 0;
    gap:12px;
  }
  #christmasLights .lights-cable{
    position:absolute;
    top:14px;
    left:0;
    right:0;
    height:94px;
    width:100%;
  }
  #christmasLights .lights-cable path{
    fill:none;
    stroke:rgba(31,41,55,.32);
    stroke-width:3;
    stroke-linecap:round;
    stroke-linejoin:round;
  }
  #christmasLights .light-bulb{
    position:relative;
    width:26px;
    height:46px;
    flex:0 0 auto;
    margin-top:var(--bulb-offset,0px);
    transform-origin:top center;
    animation:lightSway 2.8s ease-in-out infinite;
    animation-delay:var(--twinkle-delay,0s);
    will-change:transform;
    contain:layout paint;
  }
  #christmasLights .light-bulb::before{
    content:"";
    display:block;
    width:18px;
    height:26px;
    margin:10px auto 0;
    background:radial-gradient(circle at 50% 35%, color-mix(in srgb, var(--bulb-color,#f87171) 92%, #fff) 0%, color-mix(in srgb, var(--bulb-color,#f87171) 88%, transparent) 46%, color-mix(in srgb, var(--bulb-color,#f87171) 48%, transparent) 100%);
    border-radius:50% 50% 55% 55%;
    box-shadow:
      0 0 26px color-mix(in srgb,var(--bulb-color,#f87171) 75%,transparent),
      0 0 84px color-mix(in srgb,var(--bulb-color,#f87171) 52%,transparent);
    mix-blend-mode:screen;
    animation:lightPulse 2.6s ease-in-out infinite;
    animation-delay:var(--twinkle-delay,0s);
    transform-origin:50% 38%;
    will-change:opacity,transform;
  }
  #christmasLights .light-bulb::after{
    content:"";
    position:absolute;
    top:4px;
    left:50%;
    width:12px;
    height:10px;
    background:#1f2937;
    border-radius:3px;
    transform:translateX(-50%);
  }
  #christmasLights.lights--static .light-bulb,
  #christmasLights.lights--static .light-bulb::before{
    animation:none;
  }
  @keyframes lightSway{
    0%{transform:rotate(-4deg);}
    50%{transform:rotate(4deg);}
    100%{transform:rotate(-4deg);}
  }
  @keyframes lightPulse{
    0%,100%{
      opacity:.85;
      transform:scale(.96);
    }
    50%{
      opacity:1;
      transform:scale(1.02);
    }
  }
  @media (prefers-reduced-motion: reduce){
    #christmasLights .light-bulb,
    #christmasLights .light-bulb::before{
      animation:none;
    }
  }
  </style>
  <script>
  (()=>{
    const DEFAULT_LEVEL='medium';
    const DENSITY_MAP={off:0,light:0.55,medium:1,heavy:1.35};
    const LAYERS=[
      { id:'snow-far', base:60, speed:0.28, size:1.1, alpha:0.38, sway:0.22 },
      { id:'snow-mid', base:90, speed:0.46, size:1.6, alpha:0.55, sway:0.36 },
      { id:'snow-near', base:50, speed:0.82, size:2.3, alpha:0.85, sway:0.48 },
    ];

    const state={
      density:DEFAULT_LEVEL,
      factor:DENSITY_MAP[DEFAULT_LEVEL],
      targetFactor:DENSITY_MAP[DEFAULT_LEVEL],
      layer:null,
      layers:[],
      width:0,
      height:0,
      cssWidth:0,
      cssHeight:0,
      dpr:window.devicePixelRatio||1,
      rafId:null,
      animating:false,
      lastFrameTime:0,
      resizeHandler:null,
      motionQuery:window.matchMedia?window.matchMedia('(prefers-reduced-motion: reduce)'):null,
      fadeAnimation:null,
      userDisabled:false,
      active:false,
    };

    function ensureLayer(){
      if(state.layer) return true;
      const layer=document.getElementById('fx-layer');
      if(!layer) return false;
      state.layer=layer;
      state.layers=LAYERS.map(config=>{
        const canvas=layer.querySelector(`#${config.id}`);
        const ctx=canvas?.getContext('2d',{ alpha:true });
        return { config, canvas, ctx, flakes:[] };
      });
      return true;
    }

    function resizeCanvases(){
      if(!ensureLayer()) return;
      const cssWidth=window.innerWidth||document.documentElement.clientWidth||0;
      const cssHeight=window.innerHeight||document.documentElement.clientHeight||0;
      const scaledDpr=Math.max(1,Math.min(3,window.devicePixelRatio||1));
      const width=Math.max(1,Math.floor(cssWidth*scaledDpr));
      const height=Math.max(1,Math.floor(cssHeight*scaledDpr));

      state.cssWidth=cssWidth;
      state.cssHeight=cssHeight;
      state.dpr=scaledDpr;
      state.width=width;
      state.height=height;

      state.layers.forEach(layer=>{
        if(!layer.canvas) return;
        layer.canvas.width=width;
        layer.canvas.height=height;
        layer.canvas.style.width=`${cssWidth}px`;
        layer.canvas.style.height=`${cssHeight}px`;
      });
    }

    function createFlake(config){
      const radius=(Math.random()*config.size+0.6)*state.dpr;
      return {
        x:Math.random()*state.width,
        y:Math.random()*state.height,
        radius,
        vy:(Math.random()*0.45+config.speed)*state.dpr,
        vx:(Math.random()*0.3-0.15)*config.speed*state.dpr,
        sway:Math.random()*Math.PI*2,
        swaySpeed:(Math.random()*0.012+0.004)*(0.8+config.speed),
        swayAmp:(Math.random()*0.6+0.4)*config.sway*state.dpr*2.4,
      };
    }

    function populateLayer(layer){
      const { config, ctx }=layer;
      if(!ctx){
        layer.flakes=[];
        return;
      }
      const count=Math.round((config.base||0)*state.factor);
      if(count<=0){
        layer.flakes=[];
        ctx.clearRect(0,0,state.width,state.height);
        return;
      }
      const flakes=[];
      for(let i=0;i<count;i++){
        flakes.push(createFlake(config));
      }
      layer.flakes=flakes;
    }

    function totalFlakes(){
      return state.layers.reduce((sum,layer)=>sum+layer.flakes.length,0);
    }

    function render(now){
      if(!state.animating){
        state.rafId=null;
        return;
      }
      if(!state.lastFrameTime){
        state.lastFrameTime=now;
      }
      const delta=Math.min(now-state.lastFrameTime,160);
      const step=delta/16.6667;
      state.lastFrameTime=now;

      let drawn=0;
      state.layers.forEach(layer=>{
        const { ctx, flakes, config }=layer;
        if(!ctx){
          return;
        }
        ctx.clearRect(0,0,state.width,state.height);
        if(!flakes.length){
          return;
        }
        drawn+=flakes.length;
        ctx.save();
        ctx.fillStyle=`rgba(255,255,255,${config.alpha})`;
        flakes.forEach(flake=>{
          flake.x+=flake.vx*step+Math.cos(flake.sway)*flake.swayAmp*step;
          flake.y+=flake.vy*step;
          flake.sway+=flake.swaySpeed*step;

          if(flake.y>state.height+flake.radius){
            flake.y=-flake.radius;
            flake.x=Math.random()*state.width;
          }
          if(flake.x<-flake.radius){
            flake.x=state.width+flake.radius;
          }else if(flake.x>state.width+flake.radius){
            flake.x=-flake.radius;
          }

          ctx.beginPath();
          ctx.arc(flake.x,flake.y,flake.radius,0,Math.PI*2);
          ctx.fill();
        });
        ctx.restore();
      });

      if(drawn===0){
        stopAnimation();
        return;
      }

      state.rafId=requestAnimationFrame(render);
    }

    function startAnimation(){
      if(state.animating) return;
      if(totalFlakes()<=0) return;
      state.animating=true;
      state.lastFrameTime=0;
      state.rafId=requestAnimationFrame(render);
    }

    function stopAnimation(){
      state.animating=false;
      if(state.rafId){
        cancelAnimationFrame(state.rafId);
        state.rafId=null;
      }
      state.lastFrameTime=0;
    }

    function ensureActive(){
      if(state.motionQuery?.matches) return false;
      if(!ensureLayer()) return false;
      if(!state.active){
        resizeCanvases();
        state.active=true;
        if(!state.resizeHandler){
          state.resizeHandler=()=>{
            if(!state.active) return;
            resizeCanvases();
            state.layers.forEach(populateLayer);
            startAnimation();
          };
          window.addEventListener('resize',state.resizeHandler,{ passive:true });
        }
      }
      return true;
    }

    function fadeIn(){
      if(!state.layer) return;
      state.layer.hidden=false;
      if(state.fadeAnimation){
        state.fadeAnimation.cancel();
      }
      if(state.layer.animate){
        const anim=state.layer.animate([
          { opacity:0 },
          { opacity:1 }
        ],{ duration:1200, easing:'ease-out', fill:'forwards' });
        state.fadeAnimation=anim;
        anim.onfinish=()=>{ state.layer.style.opacity='1'; state.fadeAnimation=null; };
        anim.oncancel=()=>{ state.layer.style.opacity='1'; state.fadeAnimation=null; };
      }else{
        state.layer.style.opacity='1';
      }
    }

    function showStaticLayer(){
      if(!ensureLayer()) return;
      resizeCanvases();
      stopAnimation();
      if(state.fadeAnimation){
        state.fadeAnimation.oncancel=null;
        state.fadeAnimation.onfinish=null;
        state.fadeAnimation.cancel();
        state.fadeAnimation=null;
      }
      if(state.resizeHandler){
        window.removeEventListener('resize',state.resizeHandler);
        state.resizeHandler=null;
      }
      state.active=false;
      state.layers.forEach(layer=>{
        layer.flakes=[];
        layer.ctx?.clearRect(0,0,state.width,state.height);
      });
      state.layer.hidden=false;
      state.layer.style.opacity='1';
    }

    function finalizeFadeOut(){
      stopAnimation();
      state.layers.forEach(layer=>{
        layer.flakes=[];
        layer.ctx?.clearRect(0,0,state.width,state.height);
      });
      if(state.layer){
        state.layer.hidden=true;
        state.layer.style.opacity='0';
      }
      if(state.resizeHandler){
        window.removeEventListener('resize',state.resizeHandler);
        state.resizeHandler=null;
      }
      state.active=false;
      state.fadeAnimation=null;
    }

    function fadeOut(){
      if(!state.layer){
        finalizeFadeOut();
        return Promise.resolve();
      }
      if(state.fadeAnimation){
        state.fadeAnimation.cancel();
      }
      const current=parseFloat(getComputedStyle(state.layer).opacity)||1;
      if(state.layer.animate){
        return new Promise(resolve=>{
          const done=()=>{
            finalizeFadeOut();
            resolve();
          };
          const anim=state.layer.animate([
            { opacity:current },
            { opacity:0 }
          ],{ duration:700, easing:'ease-in-out', fill:'forwards' });
          state.fadeAnimation=anim;
          anim.onfinish=done;
          anim.oncancel=done;
        });
      }
      finalizeFadeOut();
      return Promise.resolve();
    }

    function refreshFlakes(){
      if(!ensureActive()) return;
      state.layers.forEach(populateLayer);
      if(totalFlakes()>0){
        fadeIn();
        startAnimation();
      }else{
        fadeOut();
      }
    }

    function setDensity(level){
      const normalized=level && Object.prototype.hasOwnProperty.call(DENSITY_MAP,level)?level:DEFAULT_LEVEL;
      const factor=DENSITY_MAP[normalized];
      state.density=normalized;
      state.factor=factor;
      state.targetFactor=factor;
      state.userDisabled=false;

      resizeCanvases();

      if(state.motionQuery?.matches){
        if(factor<=0){
          fadeOut();
        }else{
          showStaticLayer();
        }
        return;
      }

      if(factor<=0){
        fadeOut();
        return;
      }

      refreshFlakes();
    }

    function refresh(){
      if(state.motionQuery?.matches) return;
      if(state.userDisabled) return;
      if(state.targetFactor<=0) return;
      state.factor=state.targetFactor;
      resizeCanvases();
      refreshFlakes();
    }

    function destroy(){
      state.userDisabled=true;
      state.targetFactor=0;
      return fadeOut();
    }

    function handleMotionChange(event){
      if(event.matches){
        if(state.targetFactor>0){
          showStaticLayer();
        }else{
          fadeOut();
        }
      }else if(!state.userDisabled && state.targetFactor>0){
        state.factor=state.targetFactor;
        resizeCanvases();
        refreshFlakes();
      }else{
        fadeOut();
      }
    }

    if(state.motionQuery){
      if(state.motionQuery.addEventListener){
        state.motionQuery.addEventListener('change',handleMotionChange);
      }else if(state.motionQuery.addListener){
        state.motionQuery.addListener(handleMotionChange);
      }
    }

    const api={ setDensity, refresh, destroy };
    window.WinterOverlay=api;
  })();

  </script>
  <script>
  (()=>{
    const COLORS=['#f97316','#fde047','#34d399','#60a5fa','#f472b6'];
    const COUNT=18;
    const motionQuery=window.matchMedia?window.matchMedia('(prefers-reduced-motion: reduce)'):null;
    let container=null;
    let enabled=false;

    function prefersReducedMotion(){
      return motionQuery?.matches ?? false;
    }

    function ensure(){
      if(container) return;
      container=document.createElement('div');
      container.id='christmasLights';
      container.setAttribute('aria-hidden','true');
      const strand=document.createElement('div');
      strand.className='lights-strand';
      const cable=document.createElementNS('http://www.w3.org/2000/svg','svg');
      cable.classList.add('lights-cable');
      cable.setAttribute('viewBox','0 0 100 60');
      cable.setAttribute('preserveAspectRatio','none');
      const cablePath=document.createElementNS('http://www.w3.org/2000/svg','path');
      cablePath.setAttribute('d','M0 26 C 18 66, 26 66, 38 26 S 62 -14, 74 26 S 88 66, 100 26');
      cable.appendChild(cablePath);
      for(let i=0;i<COUNT;i++){
        const bulb=document.createElement('span');
        bulb.className='light-bulb';
        bulb.style.setProperty('--bulb-color', COLORS[i % COLORS.length]);
        bulb.style.setProperty('--twinkle-delay', `${(i % COLORS.length)*0.18}s`);
        const t=COUNT>1?i/(COUNT-1):0;
        const wave=Math.pow(Math.sin(t*Math.PI*2),2);
        const offset=8+wave*28;
        bulb.style.setProperty('--bulb-offset', `${offset.toFixed(2)}px`);
        strand.appendChild(bulb);
      }
      container.appendChild(cable);
      container.appendChild(strand);
      document.body.appendChild(container);
      updateMotionState();
    }

    function updateMotionState(){
      if(!container) return;
      if(prefersReducedMotion()){
        container.classList.add('lights--static');
      }else{
        container.classList.remove('lights--static');
      }
    }

    function render(){
      if(!container){
        if(!enabled) return;
        ensure();
      }
      updateMotionState();
      if(!container) return;
      container.style.display=enabled && !prefersReducedMotion() ? 'block' : 'none';
    }

    function enable(){
      enabled=true;
      ensure();
      render();
    }

    function disable(){
      enabled=false;
      if(container){
        container.style.display='none';
      }
    }

    if(motionQuery){
      const handler=()=>{
        updateMotionState();
        render();
      };
      if(motionQuery.addEventListener){
        motionQuery.addEventListener('change', handler);
      }else if(motionQuery.addListener){
        motionQuery.addListener(handler);
      }
    }

    window.ChristmasLights={
      enable(){ enable(); },
      disable(){ disable(); },
      refresh(){ render(); }
    };
  })();
  </script>
  <script>

  let __loadController = null;

const $loading = () => document.getElementById('loadingOverlay');
const getWeekBadge = () => document.getElementById('week-badge');
const showLoading = (message = 'Loading…') => {
  const overlay = $loading();
  if (overlay) overlay.style.display = 'grid';
  const badge = getWeekBadge();
  if (badge) {
    badge.hidden = false;
    badge.dataset.state = 'loading';
    badge.textContent = message;
  }
};
const hideLoading = () => {
  const overlay = $loading();
  if (overlay) overlay.style.display = 'none';
};

async function loadChosenGid(meta, { bust=false } = {}){
  if (__loadController) __loadController.abort();
  __loadController = new AbortController();

  try{
    if (!meta || !meta.gid) {
      throw new Error('Selected week is missing a valid gid');
    }

const base = meta.url ? meta.url : csvUrlForGid(meta.gid);
const url  = bust ? withBust(base) : base;
    console.log('[loadChosenGid] gid:', meta.gid, 'url:', url);

    const res = await fetch(url, { signal: __loadController.signal });
    if(!res.ok) {
      // show status code/message if Google returns an error
      throw new Error(`Fetch failed (${res.status} ${res.statusText})`);
    }

    const text = await res.text();
    if (!text || !text.trim()) {
      throw new Error('Fetched CSV is empty');
    }
    console.log('[loadChosenGid] first 200 chars of CSV:', text.slice(0,200));

    let headers, rows;
    try {
      ({ headers, rows } = parseDelimited(text));
    } catch (pErr) {
      console.error('[parseDelimited] failed:', pErr);
      throw new Error('Could not parse CSV – check delimiters/quotes');
    }

    try {
      rows = dedupeRows(rows);
    } catch (dErr) {
      console.error('[dedupeRows] failed:', dErr);
      throw new Error('Row dedupe failed – check required columns like ID/Title/Created on');
    }

    saveWeekToCache(meta, { headers, rows });

    LAST_HEADERS = headers;
    ALL_ROWS     = rows;
    setWeekBadge(meta.label || meta.weekEnd);

    try {
      ingestToDashboards(LAST_HEADERS, ALL_ROWS);
    } catch (rErr) {
      console.error('[ingest/render] failed:', rErr);
      throw new Error('Rendering failed – see console for details');
    }
  } catch (e){
    if (e.name !== 'AbortError') {
      console.error('[loadChosenGid] error:', e);
      alert('Could not load the selected week. ' + (e?.message || ''));
    }
  } finally {
    __loadController = null;
  }
}

async function refreshInBG(meta){
  if(!meta) return null;

  const resolveUrl = () => {
    if(meta.url) return meta.url;
    if(meta.gid != null) return csvUrlForGid(meta.gid);
    return null;
  };

  const url = resolveUrl();
  if(!url) return null;

  try {
    const res = await fetch(url);
    if(!res.ok){
      throw new Error(`Fetch failed (${res.status} ${res.statusText})`);
    }

    const text = await res.text();
    if(!text || !text.trim()){
      throw new Error('Fetched CSV is empty');
    }

    let headers, rows;
    try {
      ({ headers, rows } = parseDelimited(text));
    } catch (pErr) {
      console.error('[refreshInBG] parseDelimited failed:', pErr);
      throw new Error('Could not parse CSV – check delimiters/quotes');
    }

    try {
      rows = dedupeRows(rows);
    } catch (dErr) {
      console.error('[refreshInBG] dedupeRows failed:', dErr);
      throw new Error('Row dedupe failed – check required columns like ID/Title/Created on');
    }

    const cached = saveWeekToCache(meta, { headers, rows }) || { headers, rows };

    const eq = (a,b) => String(a ?? '') === String(b ?? '');
    let isCurrent = false;
    if(__WEEK_SELECTED && meta.weekEnd){
      isCurrent = eq(meta.weekEnd, __WEEK_SELECTED);
    }

    if(!isCurrent && meta.gid != null){
      const selectedWeek = __WEEKS.find(w => eq(w.weekEnd, __WEEK_SELECTED));
      if(selectedWeek && selectedWeek.gid != null){
        isCurrent = eq(selectedWeek.gid, meta.gid);
      }

      if(!isCurrent){
        const byGid = __WEEKS.find(w => w?.gid != null && eq(w.gid, meta.gid));
        if(byGid && byGid.weekEnd && __WEEK_SELECTED){
          isCurrent = eq(byGid.weekEnd, __WEEK_SELECTED);
        }
      }
    }

    if(!isCurrent){
      return cached;
    }

    const nextHeaders = Array.isArray(cached.headers) ? cached.headers.slice() : Array.isArray(headers) ? headers.slice() : [];
    const nextRows = Array.isArray(cached.rows) ? cached.rows.slice() : Array.isArray(rows) ? rows.slice() : [];

    LAST_HEADERS = nextHeaders;
    ALL_ROWS = nextRows;
    setWeekBadge(meta.label || meta.weekEnd);
    ingestToDashboards(LAST_HEADERS, ALL_ROWS);

    return cached;
  } catch(err){
    if(err?.name === 'AbortError') return null;
    console.error('[refreshInBG] failed:', err);
    return null;
  }
}

// Published CSV of the *Index* tab
const SHEET_INDEX_CSV_URL =
  'https://docs.google.com/spreadsheets/d/e/2PACX-1vRJocigDhxneJtrUmezFU7FcWpzSSah8-Wb6Rce8NA1f7jKcINgYU29iYRqt5QQymWATX5zs5k8_rK0/pub?single=true&output=csv&gid=105348743';
  
// --- Layout helpers ---
const $stickyTop = document.querySelector('.sticky-top');
const rootStyle = document.documentElement.style;
function updateStickyControlsOffset(){
  if(!$stickyTop || !rootStyle) return;
  const styles = getComputedStyle($stickyTop);
  const marginBottom = parseFloat(styles.marginBottom) || 0;
  const offset = $stickyTop.getBoundingClientRect().height + marginBottom;
  rootStyle.setProperty('--sticky-controls-offset', `${offset}px`);
}
updateStickyControlsOffset();
window.addEventListener('resize', updateStickyControlsOffset);
window.addEventListener('load', updateStickyControlsOffset);
if('ResizeObserver' in window && $stickyTop){
  const observer = new ResizeObserver(updateStickyControlsOffset);
  observer.observe($stickyTop);
}

  // Measure everything that sits above the tables and keep a dynamic offset.
// It shrinks as the title/logo scroll out of view, so the table header
// always hugs the bottom of the visible top UI without leaving a blue gap.
function updateUiOffset(){
  const head   = document.querySelector('.page-head');
  const rule   = document.querySelector('.top-rule');
  const sticky = document.querySelector('.sticky-top');
  const kpis   = document.querySelector('.kpi-panels');

  const rectH = el => (el ? el.getBoundingClientRect().height : 0);
  const mb    = el => (el ? parseFloat(getComputedStyle(el).marginBottom) || 0 : 0);

  // How much of the title+rule is still visible at the top of the viewport?
  const headAndRuleTotal = rectH(head) + rectH(rule);
  const scrolledPast     = Math.min(window.scrollY || 0, headAndRuleTotal);
  const headAndRuleInView = Math.max(0, headAndRuleTotal - scrolledPast);

  // Sticky block stays in view; include its margin-bottom to match layout.
  const stickyBlock = rectH(sticky) + mb(sticky);
  
  // KPI panels also stay in view
  const kpiBlock = rectH(kpis) + mb(kpis);

  const offset = Math.round(headAndRuleInView + stickyBlock + kpiBlock);
  document.documentElement.style.setProperty('--ui-offset', `${offset}px`);
}
function updateTableMaxHeight(){
  const scroller =
    document.querySelector('.dash-table[data-active="true"] .table-scroll') ||
    document.querySelector('.table-scroll');
  if (!scroller) return;

  const top = scroller.getBoundingClientRect().top;
  const available = Math.max(200, window.innerHeight - Math.max(0, Math.round(top)));
  scroller.style.maxHeight = available + 'px';
}
  // visual feedback flash when filters/sorts apply
function pulse(el, cls='filter-flash'){
  if(!el) return;
  el.classList.remove(cls);
  // force reflow so the animation retriggers
  void el.offsetWidth;
  el.classList.add(cls);
}

// keep both helpers in sync (either keep your old one or just call this)
function wireUiOffsetObservers(){
  updateUiOffset();
  window.addEventListener('scroll', updateUiOffset, { passive: true });
  window.addEventListener('resize', updateUiOffset);
  window.addEventListener('load', updateUiOffset);
  
  if ('ResizeObserver' in window){
    const ro = new ResizeObserver(updateUiOffset);
    const sticky = document.querySelector('.sticky-top');
    const head   = document.querySelector('.page-head');
    const rule   = document.querySelector('.top-rule');
    const kpis   = document.querySelector('.kpi-panels');
    sticky && ro.observe(sticky);
    head   && ro.observe(head);
    rule   && ro.observe(rule);
    kpis   && ro.observe(kpis);
  }
}
  
wireUiOffsetObservers();

  const MS = { min:6e4, hour:36e5, day:864e5 };
  const MIN_AGE_MINUTES = 30;

function parseCreated(r){ return parseDateLoose(r['Created on']); }
function parseCompleted(r){ return parseDateLoose(r['Completed on']); }

function ageMs(row){
  const created = parseCreated(row); if(!created) return null;
  const done = /^done$/i.test(row['Status']);
  const end = done ? (parseCompleted(row) || new Date()) : new Date();
  const diff = end - created;
  return Number.isFinite(diff) && diff >= 0 ? diff : null;
}

function ageBucket(ms){
  if(ms==null) return 'fresh';
  const d = ms / MS.day;
  if(d < 7) return 'fresh';
  if(d < 30) return 'stale';
  if(d < 90) return 'old';
  return 'ancient';
}

function fmtAge(ms){
  if(ms == null) return '—';
  if(ms < MS.hour){
    const minutes = Math.floor(ms / MS.min);
    const clamped = Math.max(MIN_AGE_MINUTES, minutes);
    return `${clamped}m`;
  }
  if(ms < MS.day){
    return `${Math.floor(ms / MS.hour)}h`; // under 24h: hours only
  }
  // ≥ 24h: days only (no hours)
  const d = Math.floor(ms / MS.day);
  return `${d}d`;
}

function normalizeAgeLabel(raw){
  if(raw == null) return raw;
  const trimmed = String(raw).trim();
  const match = trimmed.match(/^(\d+)\s*m(?:in(?:s)?)?$/i);
  if(match){
    const minutes = parseInt(match[1], 10);
    const clamped = Math.max(MIN_AGE_MINUTES, minutes);
    return `${clamped}m`;
  }
  return trimmed;
}

function getAgeLabel(row){
  if(!row) return '—';
  const ms = row.__ageMs;
  if(ms != null){
    return fmtAge(ms);
  }
  const normalized = normalizeAgeLabel(row['Age']);
  return normalized || '—';
}

// --- State cache for rendering ---
let LAST_HEADERS = null;
let ALL_ROWS = null;
let __LAST_FILTERS_JSON = null;

// --- Week data cache (in-memory) ---
const WEEK_CACHE_LIMIT = 6;
const WEEK_CACHE_BY_WEEK = new Map();
const WEEK_CACHE_BY_GID = new Map();

function cloneWeekEntry(entry){
  if(!entry) return null;
  return {
    meta: { ...(entry.meta || {}) },
    headers: Array.isArray(entry.headers) ? entry.headers.slice() : [],
    rows: Array.isArray(entry.rows) ? entry.rows.map(row => ({ ...(row || {}) })) : []
  };
}

function trimWeekCache(map){
  while(map.size > WEEK_CACHE_LIMIT){
    const oldestKey = map.keys().next().value;
    if(oldestKey == null) break;
    map.delete(oldestKey);
  }
}

function saveWeekToCache(meta, payload){
  if(!meta || !payload) return null;

  const headers = Array.isArray(payload.headers) ? payload.headers.slice() : [];
  const rows = Array.isArray(payload.rows) ? payload.rows.map(row => ({ ...(row || {}) })) : [];
  const entry = { meta: { ...(meta || {}) }, headers, rows };

  if(meta.weekEnd){
    WEEK_CACHE_BY_WEEK.set(String(meta.weekEnd), entry);
    trimWeekCache(WEEK_CACHE_BY_WEEK);
  }
  if(meta.gid != null){
    WEEK_CACHE_BY_GID.set(String(meta.gid), entry);
    trimWeekCache(WEEK_CACHE_BY_GID);
  }

  return entry;
}

function loadWeekFromCache(meta){
  if(!meta) return null;
  const weekKey = meta.weekEnd != null ? String(meta.weekEnd) : null;
  if(weekKey && WEEK_CACHE_BY_WEEK.has(weekKey)){
    return cloneWeekEntry(WEEK_CACHE_BY_WEEK.get(weekKey));
  }

  const gidKey = meta.gid != null ? String(meta.gid) : null;
  if(gidKey && WEEK_CACHE_BY_GID.has(gidKey)){
    return cloneWeekEntry(WEEK_CACHE_BY_GID.get(gidKey));
  }

  return null;
}

const $exportCsvBtn = document.getElementById('exportCsvBtn');

function hasSheetData(){
  return Array.isArray(LAST_HEADERS) && LAST_HEADERS.length > 0;
}

function updateExportButtonsState(){
  const hasData = hasSheetData();
  [$exportCsvBtn].forEach(btn => {
    if(!btn) return;
    btn.disabled = !hasData;
    if(!hasData){
      btn.title = 'Sheet data is still loading';
    }else{
      btn.removeAttribute('title');
    }
  });
}
updateExportButtonsState();

function csvEscape(value){
  const str = String(value ?? '');
  return /[",\n\r]/.test(str) ? `"${str.replace(/"/g,'""')}"` : str;
}

  /* ========= Week arrows hookup ========= */

/* cache the weeks list + current selection so external arrows can work */
let __WEEKS = [];          // [{label, weekEnd, gid}, ...]
let __WEEK_SELECTED = null; // string weekEnd

/* Move by an offset relative to the current option (list is newest-first) */
function gotoWeekByOffset(offset){
  if (!__WEEKS.length) return;
  const idx = __WEEKS.findIndex(w => w.weekEnd === __WEEK_SELECTED);
  const next = idx + offset;
  if (next < 0 || next >= __WEEKS.length) return;
  setSelectedWeek(__WEEKS[next]);
  // also refresh enable/disable state on any arrows we can see
  refreshWeekArrowDisabled();
}

/* Enable/disable whichever arrow buttons exist */
function refreshWeekArrowDisabled(){
  const idx = __WEEKS.findIndex(w => w.weekEnd === __WEEK_SELECTED);
  const prevs = document.querySelectorAll('#weekPrev,[data-week-nav="prev"]');
  const nexts = document.querySelectorAll('#weekNext,[data-week-nav="next"]');
  prevs.forEach(btn => btn.disabled = (idx === __WEEKS.length - 1));
  nexts.forEach(btn => btn.disabled = (idx <= 0));
}

  function debounce(fn, ms=160){
  let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
}

/* ========= integrate with your existing functions ========= */

/* 1) After we fetch the index and choose the week, remember it globally */
async function loadLatestOrChosenWeek(forceBust=false){
  try{
    let weeks;
    if (forceBust){
      const bustUrl = new URL(SHEET_INDEX_CSV_URL);
      bustUrl.searchParams.set('_ts', Date.now());
      weeks = await loadWeeksIndexFrom(bustUrl.toString());
    } else {
      weeks = await loadWeeksIndex();
    }
    if (!weeks.length) throw new Error('Index is empty');

    __WEEKS = weeks.slice();                                // <—
    const chosen = chooseInitialWeek(__WEEKS);
    __WEEK_SELECTED = chosen.weekEnd;                       // <—

    renderWeekControls(__WEEKS, chosen);
    rememberWeek(chosen);
await loadChosenGid(chosen, { bust: forceBust });
    prefetchAdjacent(__WEEKS, chosen);   // <— add this line

    wireExternalWeekArrows();                               // <— bind external arrows
    refreshWeekArrowDisabled();
  }catch(err){
    console.error(err);
    alert('Could not load the latest dashboard. Check the Index publish URL and columns (label, week_end, gid).');
  }
}
  
document.addEventListener('DOMContentLoaded', () => {
  PREFERRED_ACTIVE_DASH = 'dash-all';
  loadLatestOrChosenWeek();  // this will call ingest → setActiveDash(...) for you
});
  
function renderWeekControls(weeks, chosen){
  const wrap = document.getElementById('weekPicker');
  if(!wrap) return;
  wrap.innerHTML = '';

  const sel = document.createElement('select');
  sel.setAttribute('aria-label', 'Select dates');

  sel.innerHTML = weeks.map((w, i) => {
    const isSelected = (w.weekEnd === chosen.weekEnd);
    return `<option value="${i}"${isSelected ? ' selected' : ''}>
              ${esc(w.label || w.weekEnd)}
            </option>`;
  }).join('');

  sel.addEventListener('change', () => {
    const idx = Number(sel.value);
    const wk = weeks[idx];
    if (wk){
      setSelectedWeek(wk);
      refreshWeekArrowDisabled();
    }
  });

  wrap.append(sel);
  refreshWeekArrowDisabled();
}

function setSelectedWeek(weekObj){
  __WEEK_SELECTED = weekObj?.weekEnd || null;
  rememberWeek(weekObj);

  // keep URL tidy
  const url = new URL(location.href);
  url.searchParams.set('week', weekObj.weekEnd);
  url.searchParams.delete('gid');
  history.replaceState({}, '', url);

  // sync the dropdown
  const sel = document.querySelector('#weekPicker select');
  if (sel){
    const i = __WEEKS.findIndex(w => w.weekEnd === weekObj.weekEnd);
    if (i >= 0) sel.value = String(i);
  }

  // 1) if cached → render immediately (instant)
  const cached = loadWeekFromCache(weekObj);
  if (cached){
    LAST_HEADERS = cached.headers;
    ALL_ROWS     = cached.rows;
    setWeekBadge(weekObj.label || weekObj.weekEnd);
    ingestToDashboards(LAST_HEADERS, ALL_ROWS);

    // 2) revalidate in background (quietly updates if changed)
    refreshInBG(weekObj);
  } else {
    // first visit to this week → show loading once
    showLoading?.();
    loadChosenGid(weekObj).finally(()=> hideLoading?.());
  }

  // 3) speculative preload for next/prev weeks
  prefetchAdjacent(__WEEKS, weekObj);
}
  
function renderRowsSmart(tbodyEl, headers, rows, container){
  if (isMobileView() || (rows?.length ?? 0) < 600) {
    return renderRowsScoped(tbodyEl, headers, rows, container);
  }
  return renderRowsScopedChunked(tbodyEl, headers, rows, container);
}

function renderRowsScoped(tbodyEl, headers, rows, container){
  const mobile = isMobileView();
  const safeRows = Array.isArray(rows) ? rows : [];
  if (!tbodyEl) return;

  if (!mobile){
    // DESKTOP: render table rows
    tbodyEl.innerHTML = safeRows.map(row => {
      const rowCls = hasPriorityCategory(row) ? 'row-priority' : '';
      return `<tr class="${rowCls}">` + headers.map(h => {
        const key = String(h||'').trim().toLowerCase();
        const v = row[h];

        if (key === 'categories'){
          return `<td data-col="Categories"><div class="chip-stack">${buildCategoryChips(v)}</div></td>`;
        }
        if (key === 'status'){
          return `<td data-col="Status"><span class="status-chip ${statusClass(v)}">${esc(v)}</span></td>`;
        }
        if (key === 'age'){
          const ms      = row.__ageMs;
          const bucket  = row.__ageBucket || ageBucket(ms);
          const label   = esc(getAgeLabel(row));
          const baseT   = ms != null ? `${(ms/86400000).toFixed(1)} days` : 'Unknown';
          const frozen  = isWinterPlanned(row);
          const pwp     = categoryColors['planned-winter-project'] || { background:'#E7F3FE', foreground:'#1887FC' };
          const style   = frozen ? ` style="--bg:${pwp.background}; --ring: color-mix(in srgb, ${pwp.foreground} 50%, transparent); color:${pwp.foreground}"` : '';
          const cls     = `age-chip age-${bucket}` + (frozen ? ' frozen' : '');
          const title   = frozen ? `Planned for Winter • ${baseT}` : baseT;
          const aria    = frozen ? ' aria-label="Planned for Winter"' : '';
          return `<td data-col="Age"><span class="${cls}"${style} title="${esc(title)}"${aria}>${label}</span></td>`;
        }
        return `<td data-col="${esc(h)}">${esc(v)}</td>`;
      }).join('') + `</tr>`;
    }).join('\n');

    const hasRows = safeRows.length > 0;
    container?.__tableWrap && (container.__tableWrap.hidden = !hasRows);
    setMobileSortVisibility(container, false);
    container?.__mobileCards && (container.__mobileCards.hidden = true);
    container?.__emptyState && (container.__emptyState.hidden = hasRows);
    updateTheadHeight();
    return;
  }

  // MOBILE: render cards
  tbodyEl.innerHTML = '';
  if (container?.__mobileCards){
    container.__mobileCards.innerHTML = safeRows.map(cardHTML).join('');
    const hasRows = safeRows.length > 0;
    container.__tableWrap && (container.__tableWrap.hidden = true);
    setMobileSortVisibility(container, hasRows);
    container.__mobileCards.hidden = !hasRows;
    container.__emptyState && (container.__emptyState.hidden = hasRows);
  }
}

function renderRowsScopedChunked(tbodyEl, headers, rows, container){
  if (isMobileView() || !tbodyEl) {
    return renderRowsScoped(tbodyEl, headers, rows, container);
  }

  const safe = Array.isArray(rows) ? rows : [];
  tbodyEl.innerHTML = '';
  const CHUNK = 800;
  let i = 0;

  function paintChunk(){
    let html = '';
    for (let c = 0; c < CHUNK && i < safe.length; c++, i++){
      const row = safe[i];
      const rowCls = hasPriorityCategory(row) ? 'row-priority' : '';
      html += `<tr class="${rowCls}">` + headers.map(h => {
        const key = String(h||'').trim().toLowerCase();
        const v = row[h];

        if (key === 'categories'){
          return `<td data-col="Categories"><div class="chip-stack">${buildCategoryChips(v)}</div></td>`;
        }
        if (key === 'status'){
          return `<td data-col="Status"><span class="status-chip ${statusClass(v)}">${esc(v)}</span></td>`;
        }
        if (key === 'age'){
          const ms      = row.__ageMs;
          const bucket  = row.__ageBucket || ageBucket(ms);
          const label   = esc(getAgeLabel(row));
          const baseT   = ms != null ? `${(ms/86400000).toFixed(1)} days` : 'Unknown';
          const frozen  = isWinterPlanned(row);
          const pwp     = categoryColors['planned-winter-project'] || { background:'#E7F3FE', foreground:'#1887FC' };
          const style   = frozen ? ` style="--bg:${pwp.background}; --ring: color-mix(in srgb, ${pwp.foreground} 50%, transparent); color:${pwp.foreground}"` : '';
          const cls     = `age-chip age-${bucket}` + (frozen ? ' frozen' : '');
          const title   = frozen ? `Planned for Winter • ${baseT}` : baseT;
          const aria    = frozen ? ' aria-label="Planned for Winter"' : '';
          return `<td data-col="Age"><span class="${cls}"${style} title="${esc(title)}"${aria}>${label}</span></td>`;
        }
        return `<td data-col="${esc(h)}">${esc(v)}</td>`;
      }).join('') + `</tr>`;
    }

    if (html){
      const tmp = document.createElement('tbody');
      tmp.innerHTML = html;
      while (tmp.firstChild){
        tbodyEl.appendChild(tmp.firstChild);
      }
    }

    if (i < safe.length){
      requestAnimationFrame(paintChunk);
    } else {
      const hasRows = safe.length > 0;
      container?.__tableWrap && (container.__tableWrap.hidden = isMobileView() || !hasRows);
      setMobileSortVisibility(container, isMobileView() && hasRows);
      container?.__mobileCards && (container.__mobileCards.hidden = true);
      container?.__emptyState && (container.__emptyState.hidden = hasRows);
      updateTheadHeight();
    }
  }

  requestAnimationFrame(paintChunk);
}
  
  function prefetchAdjacent(weeks, chosen){
  if (!Array.isArray(weeks) || !chosen) return;
  const idx = weeks.findIndex(w => w.weekEnd === chosen.weekEnd);
  const newer = weeks[idx - 1]; // list is newest-first
  const older = weeks[idx + 1];
  [newer, older].forEach(w => {
    if (w && !loadWeekFromCache(w)) refreshInBG(w); // fetch & cache, no re-render
  });
}

function buildCsv(headers, rows){
  const safeHeaders = Array.isArray(headers) ? headers : [];
  const safeRows = Array.isArray(rows) ? rows : [];
  const headerLine = safeHeaders.map(csvEscape).join(',');
  const lines = safeRows.map(row => safeHeaders.map(h => csvEscape(row?.[h])).join(','));
  return '\ufeff' + [headerLine, ...lines].join('\r\n');
}

function escapeForExcel(value){
  return esc(String(value ?? '')).replace(/\r?\n/g, '<br>');
}

function buildExcelHTML(headers, rows){
  const safeHeaders = Array.isArray(headers) ? headers : [];
  const head = `<tr>${safeHeaders.map(h => `<th>${escapeForExcel(h)}</th>`).join('')}</tr>`;
  const body = (Array.isArray(rows) ? rows : []).map(row => {
    const cells = safeHeaders.map(h => `<td>${escapeForExcel(row?.[h])}</td>`).join('');
    return `<tr>${cells}</tr>`;
  }).join('');
  return `<!DOCTYPE html><html><head><meta charset="utf-8" /></head><body><table><thead>${head}</thead><tbody>${body}</tbody></table></body></html>`;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  setTimeout(()=>URL.revokeObjectURL(url), 0);
}

function exportTimestamp(){
  return new Date().toISOString().replace(/[:.]/g,'-');
}

function exportSheetAsCsv(){
  if(!hasSheetData()){ alert('Sheet data is still loading.'); return; }
  const csv = buildCsv(LAST_HEADERS, ALL_ROWS);
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  downloadBlob(blob, `work-orders-${exportTimestamp()}.csv`);
}

$exportCsvBtn?.addEventListener('click', ()=>{ if(!$exportCsvBtn.disabled) exportSheetAsCsv(); });

// ---------- Utility + theming (unchanged bits you already had) ----------
const ESC_MAP = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}; const ESC_RE=/[&<>"']/g;
function esc(s){ return String(s==null?'':s).replace(ESC_RE, c => ESC_MAP[c]); }
function slugify(str){ return str.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-|-$/g,''); }

function applyColumnWidths(table, headers){
  const widthMap = {
    'ID':'66px','Title':'200px','Status':'120px','Priority':'92px','Assigned to':'160px',
    'Created on':'110px','Completed on':'110px','Last updated':'120px','Age':'96px',
    'Location':'160px','Asset':'150px','Categories':'140px'
  };
  const colgroup = document.createElement('colgroup');
  headers.forEach(h=>{
    const col = document.createElement('col');
    if(widthMap[h]) col.style.width = widthMap[h];   // ← use width
    colgroup.appendChild(col);
  });
  table.prepend(colgroup);
}

// Category presets + fallback coloring
const CATEGORY_COLOR_PRESETS=[['Search','#E7F3FE','#1887FC'],['Cleaning','#FCEBFF','#EA7BFF'],['Commission','#E7DFFD','#855EF4'],['Contractor','#FFE6CC','#A24900'],['Daily Procedures','#FFE5DF','#FF7C60'],['Damage','#FFF5CC','#CC9900'],['Electrical','#FFE4D0','#FF7439'],['Eng Weekly Meeting','#FFE5DF','#FF7C60'],['Error Codes','#FFDBE6','#FF4A80'],['Fire Safety','#FFDBE6','#FF4A80'],['First Time Fix','#E7F3FE','#1887FC'],['General improvements','#E7DFFD','#855EF4'],['Inspection','#E7F3FE','#1887FC'],['James Indust Cleaner','#D9F5F1','#3FCBBB'],['Leak','#DDF9FC','#1887FC'],['Manufacturers Machine Service Procedure','#FCEBFF','#EA7BFF'],['Mechanical','#E7F3FE','#1A66CC'],['meters','#E7F3FE','#1570B8'],['Monthly Procedures','#FFE4D0','#FF7439'],['Ordering/Purchasing','#DDF9FC','#54DFF2'],['Planned Winter Project','#E7F3FE','#1887FC'],['Plumbing','#FCEBFF','#B24BEA'],['PPM','#E4F9E8','#2FB95A'],['Preventive','#E4F9E8','#2FB95A'],['Product Quality improvements','#E7F3FE','#1887FC'],['Programming','#FFE4D0','#D85E2E'],['Project','#E7F3FE','#2A7BEF'],['Reactive Maintenance','#DDF9FC','#2CCFE3'],['Refrigeration','#D9F5F1','#3FCBBB'],['Safety','#E7F3FE','#1870DA'],['Site maintenance responsabilities','#E7F3FE','#1868C0'],['Smart Check','#FFDBE6','#E43C75'],['Standard Operating Procedure','#FFDBE6','#E43C75'],['Top 5','#E7DFFD','#6D4CE6'],['Training','#E7F3FE','#1870DA'],['Weekly Procedures','#E7F3FE','#1870DA'],['Yearly Procedures','#FFF5CC','#8A6E00'],['Priority', '#FFE2E2', '#E11D48'],['Zero Emissions','#D9F5F1','#2AAE9E']];
const categoryColors = CATEGORY_COLOR_PRESETS.reduce((a,[label,bg,fg]) => (a[slugify(label)]={background:bg,foreground:fg}, a),{});
(function injectCategoryCSS(){
  const styleEl=document.createElement('style');
  styleEl.textContent = Object.entries(categoryColors).map(([slug,c]) => `.chip-cat.cat-${slug}{background:${c.background};color:${c.foreground};border-color:${c.foreground};}`).join('');
  document.head.appendChild(styleEl);
})();
function hashCategory(label){ let h=0, s=String(label||''); for(let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); }
function hslToRgb(h,s,l){ const hue=((h%360)+360)%360, S=Math.max(0,Math.min(100,s))/100, L=Math.max(0,Math.min(100,l))/100; const c=(1-Math.abs(2*L-1))*S, x=c*(1-Math.abs(((hue/60)%2)-1)), m=L-c/2; let r1=0,g1=0,b1=0; if(hue<60){r1=c;g1=x;} else if(hue<120){r1=x;g1=c;} else if(hue<180){g1=c;b1=x;} else if(hue<240){g1=x;b1=c;} else if(hue<300){r1=x;b1=c;} else {r1=c;b1=x;} return [r1+m,g1+m,b1+m]; }
function srgbToLinear(c){ return c<=0.04045?c/12.92:Math.pow((c+0.055)/1.055,2.4); }
function relativeLuminance(rgb){ const [r,g,b]=rgb.map(v=>srgbToLinear(Math.max(0,Math.min(1,v)))); return 0.2126*r+0.7152*g+0.0722*b; }
function contrastRatio(bgH,fgH){ const lBg=relativeLuminance(hslToRgb(bgH.h,bgH.s,bgH.l)), lFg=relativeLuminance(hslToRgb(fgH.h,fgH.s,fgH.l)); const light=Math.max(lBg,lFg), dark=Math.min(lBg,lFg); return (light+0.05)/(dark+0.05); }
function fallbackColors(label){ const hue=hashCategory(label)%360, bg={h:hue,s:45,l:92}, fg0={h:hue,s:60,l:32}; let fg={...fg0}; while(contrastRatio(bg,fg)<4.5 && fg.l>0){ fg={...fg,l:Math.max(0,fg.l-10)}; } return {background:`hsl(${bg.h}, ${bg.s}%, ${bg.l}%)`, foreground:`hsl(${fg.h}, ${fg.s}%, ${fg.l}%)`}; }
function chipStyle(label, slugOverride){ const slug=slugOverride||slugify(label), preset=categoryColors[slug]; if(preset) return {className:`cat-${slug}`, style:''}; const c=fallbackColors(label); return {className:`cat-${slug}`, style:`background:${c.background};border-color:${c.foreground};color:${c.foreground}`}; }
  function hasPriorityCategory(row){
  const cats = String(row['Categories'] || '')
    .split(/[,;]+/)
    .map(s => slugify(s.trim()))
    .filter(Boolean);
  return cats.includes(slugify('Priority'));
}
// --- Name aliases / shortening ---
const NAME_ALIASES = new Map([
  ['callum keith engineering team', 'Callum'],
  ['east kilbride engineering team', 'Jim and Ciaren'],
  // add more here...
]);

function shortenName(s){
  const raw = String(s || '').trim();
  if (!raw) return '';
  const parts = raw.split(/[,;/]+/).map(p => p.trim()).filter(Boolean);
  const alias = (x) => NAME_ALIASES.get(x.toLowerCase().replace(/\s+/g,' '));
  const first = (x) => x.split(/\s+/)[0];

  if (parts.length > 1){
    const uniq = [...new Set(parts.map(p => alias(p) || first(p)))];
    return uniq.join(', ');
  }
  return alias(raw) || first(raw);
}

  // Always pass `search`, not `searchTerm`, to the chips UI
function updateChipsFromFilters(f){
  updateActiveFilterChips({
    status: f.status,
    excludeStatus: f.excludeStatus,
    priority: f.priority,
    search: f.searchTerm,   // <- the important mapping
  });
}

// CSV / JSON ingest helpers
function parseDelimited(text){
  const sep = text.includes('\t') ? '\t' : ',';
  const rows = text.trim().split(/\r?\n/).map(r =>
    r.split(new RegExp(`${sep}(?=(?:[^"]*"[^"]*")*[^"]*$)`)).map(c => c.replace(/^"|"$/g,''))
  );
  const rawHeaders = rows.shift() || [];
  const headers = rawHeaders.map((h,i)=>String(h??'').replace(/^\uFEFF/,'').trim()||`col${i}`);
  const data = rows.map(r => Object.fromEntries(r.map((v,i)=>[headers[i]||`col${i}`, v])));
  return { headers, rows: data };
}
function handleJSON(text){
  const data = JSON.parse(text);
  const rows = Array.isArray(data) ? data : (Array.isArray(data.rows) ? data.rows : []);
  const headers = rows.length ? Object.keys(rows[0]) : [];
  return { headers, rows };
}

// Site helpers / sorting / status
function toSiteKey(loc){ const s=String(loc||'').toLowerCase(); if(s.includes('byron'))return'by'; if(s.includes('mugiemoss')||s.includes('bucksburn'))return'mm'; if(s.includes('keith'))return'keith'; if(s.includes('cathkin')||s.includes('east kilbride')||s.includes('ek'))return'ek'; return'other'; }
function kpiCard(label,val){ const el=document.createElement('div'); el.className='card'; el.innerHTML=`<h3>${esc(label)}</h3><div class="big">${esc(val)}</div>`; return el; }
const PRIORITY_ORDER=['critical','high','medium','low','']; const STATUS_ORDER=['open','in-progress','on-hold','done',''];
function parseDateLoose(v){
  if(!v) return null;
  const m=String(v).trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
  if(!m) return null;
  let [,d,M,y,hh='00',mm='00']=m;
  d=d.padStart(2,'0');
  M=M.padStart(2,'0');
  hh=hh.padStart(2,'0');
  const dt=new Date(`${y}-${M}-${d}T${hh}:${mm}:00`);
  return isNaN(dt.getTime())?null:dt;
}
  // === DEDUPE HELPERS ===
function bestTimestamp(r){
  return (parseDateLoose(r['Last updated'])?.getTime())
      || (parseDateLoose(r['Completed on'])?.getTime())
      || (parseDateLoose(r['Created on'])?.getTime())
      || 0;
}
function normalizeId(v){
  return String(v ?? '')
    .trim()
    .replace(/^WO-?/i,'')        // optional: strip "WO-" prefixes
    .replace(/[^\w]/g,'')        // drop punctuation/spaces
    .toLowerCase();
}
function dedupeRows(rows){
  const map = new Map();
  for(const r of (rows||[])){
    const id = normalizeId(r['ID']);
    // fallback key if ID is empty
    const fallback = String(r['Title']||'').trim().toLowerCase()
                   + '|' + (parseDateLoose(r['Created on'])?.toISOString()?.slice(0,10) || '');
    const key = id || fallback;

    const prev = map.get(key);
    if(!prev){ map.set(key, r); continue; }

    // keep the most recently updated copy
    if(bestTimestamp(r) > bestTimestamp(prev)) map.set(key, r);
  }
  return [...map.values()];
}

// REPLACE your entire makeStatusKpi(...) with this:
function makeStatusKpi(label, statusValue, count, container){
  const el = kpiCard(label, count);
  el.classList.add('kpi-clickable');
  el.setAttribute('role','button');
  el.setAttribute('tabindex','0');
  el.setAttribute('title', `Toggle status filter: ${label}`);
  el.setAttribute('aria-label', `Toggle status filter: ${label}`);

  // pressed state mirrors current filters
  const f = getFilters();
  const pressed = f.status === statusClass(statusValue) && !f.excludeStatus;
  el.setAttribute('aria-pressed', pressed ? 'true' : 'false');

  const toggle = () => {
    const curr = getFilters();
    const isOn = curr.status === statusClass(statusValue) && !curr.excludeStatus;

    // IMPORTANT: set the <select> to the *label* values that actually exist in the options
    if ($statusFilter) {
      $statusFilter.value = isOn ? '' : label;   // "" clears; "Open" / "In Progress" / "On Hold" / "Done" applies
      // fire change so chips/ARIA stay in sync
      $statusFilter.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // re-run filter + re-render current view
    handleFilterChange();
  };

  el.addEventListener('click', toggle);
  el.addEventListener('keydown', e => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
  });

  return el;
}

// Build per-tab CSV links by swapping the gid on the SAME published doc:
const BASE_PUBLISH_URL = (() => {
  const u = new URL(SHEET_INDEX_CSV_URL);
  // strip any gid from the index link and keep everything else
  u.searchParams.delete('gid');
  return u.toString(); // .../pub?single=true&output=csv
})();

function csvUrlForGid(gid){
  const u = new URL(BASE_PUBLISH_URL);
  u.searchParams.set('gid', String(gid));
  // ensure single/output stay correct
  u.searchParams.set('single','true');
  u.searchParams.set('output','csv');
  return u.toString();
}

  function withBust(u){
  const x = new URL(u);
  x.searchParams.set('_ts', Date.now());
  return x.toString();
}

/* --- Plan for Next Week integration --- */
const PLAN_DEFAULT_DAYS = ['Monday','Tuesday','Wednesday','Thursday','Friday'];
const PLAN_DEFAULT_PEOPLE = ['Callum','Graeme','Shaun','Jim/Ciaren'];
const PLAN_FOCUS_SELECTOR = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

function normalizePlanList(value){
  if(!value) return null;
  if(Array.isArray(value)){
    const list = value.map(v => String(v ?? '').trim()).filter(Boolean);
    return list.length ? list : null;
  }
  if(typeof value === 'string'){
    const list = value.split(/[,;\n]+/).map(v => v.trim()).filter(Boolean);
    return list.length ? list : null;
  }
  return null;
}

function sanitizePlanScalar(value){
  if(value == null) return null;
  if(typeof value === 'string'){
    const trimmed = value.trim();
    if(!trimmed || trimmed === '-' || /^null$/i.test(trimmed) || /^undefined$/i.test(trimmed)) return null;
    return trimmed;
  }
  if(typeof value === 'number'){
    return Number.isFinite(value) ? String(value) : null;
  }
  if(typeof value === 'boolean'){
    return value ? '1' : null;
  }
  return null;
}

function isPlanNotePlaceholder(value){
  if(value == null) return false;
  const normalized = String(value).trim().toLowerCase();
  if(!normalized) return false;
  const stripped = normalized.replace(/[:;.,\-–—\s]+$/g, '').trim();
  return stripped === 'note' || stripped === 'notes';
}

function pickPlanScalar(...values){
  for(const v of values){
    const next = sanitizePlanScalar(v);
    if(next != null) return next;
  }
  return null;
}

function pickPlanList(...values){
  for(const v of values){
    const list = normalizePlanList(v);
    if(list) return list;
  }
  return [];
}

const planConfigFromWindow = (typeof window !== 'undefined' && window.ALS_PLAN_NEXT_WEEK_SOURCE && typeof window.ALS_PLAN_NEXT_WEEK_SOURCE === 'object')
  ? window.ALS_PLAN_NEXT_WEEK_SOURCE
  : null;

const planConfigFromBody = (() => {
  const dataset = (document.body && document.body.dataset) || {};
  return {
    gid: dataset.planGid,
    url: dataset.planUrl,
    label: dataset.planLabel,
    days: dataset.planDays,
    people: dataset.planPeople,
  };
})();

const planDays = pickPlanList(planConfigFromBody.days, planConfigFromWindow?.days, PLAN_DEFAULT_DAYS);
const planPeople = pickPlanList(planConfigFromBody.people, planConfigFromWindow?.people, PLAN_DEFAULT_PEOPLE);
const planLabelOverride = pickPlanScalar(planConfigFromBody.label, planConfigFromWindow?.label);
const planGidOverride = pickPlanScalar(planConfigFromBody.gid, planConfigFromWindow?.gid);
const planUrlOverride = pickPlanScalar(planConfigFromBody.url, planConfigFromWindow?.url);
const PLAN_LABEL_LOCKED = Boolean(planLabelOverride);
const PLAN_SOURCE_LOCKED = Boolean(planGidOverride || planUrlOverride);

let PLAN_NEXT_WEEK_SOURCE = {
  gid: planGidOverride,
  url: planUrlOverride,
  label: planLabelOverride || 'Plan for Next Week',
  days: planDays.length ? planDays : PLAN_DEFAULT_DAYS.slice(),
  people: planPeople.length ? planPeople : PLAN_DEFAULT_PEOPLE.slice(),
  meta: null,
};

const PLAN_NEXT_WEEK_DAYS = PLAN_NEXT_WEEK_SOURCE.days;
const PLAN_NEXT_WEEK_PEOPLE = PLAN_NEXT_WEEK_SOURCE.people;

const PLAN_DAY_SLUG_MAP = new Map();
PLAN_NEXT_WEEK_DAYS.forEach(day => {
  const str = String(day || '');
  const slug = slugify(str);
  if(slug) PLAN_DAY_SLUG_MAP.set(slug, day);
  const lower = str.toLowerCase();
  if(lower) PLAN_DAY_SLUG_MAP.set(lower, day);
});
const PLAN_DAY_ALIAS_TARGETS = new Map([
  ['mon','monday'], ['monday','monday'],
  ['tue','tuesday'], ['tues','tuesday'], ['tuesday','tuesday'],
  ['wed','wednesday'], ['weds','wednesday'], ['wednesday','wednesday'],
  ['thu','thursday'], ['thur','thursday'], ['thurs','thursday'], ['thursday','thursday'],
  ['fri','friday'], ['friday','friday'],
]);

const PLAN_PERSON_SLUG_MAP = new Map();
PLAN_NEXT_WEEK_PEOPLE.forEach(person => {
  const str = String(person || '');
  const slug = slugify(str);
  if(slug) PLAN_PERSON_SLUG_MAP.set(slug, person);
  const lower = str.toLowerCase();
  if(lower) PLAN_PERSON_SLUG_MAP.set(lower, person);
});
const PLAN_PERSON_ALIAS_TARGETS = new Map([
  ['callum','Callum'],
  ['callum keith','Callum'],
  ['callum keith engineering team','Callum'],
  ['graeme','Graeme'],
  ['graham','Graeme'],
  ['shaun','Shaun'],
  ['sean','Shaun'],
  ['jim','Jim/Ciaren'],
  ['ciaren','Jim/Ciaren'],
  ['jimciaren','Jim/Ciaren'],
  ['jim and ciaren','Jim/Ciaren'],
  ['jim & ciaren','Jim/Ciaren'],
  ['jim/ciaren','Jim/Ciaren'],
  ['jim and cieren','Jim/Ciaren'],
]);

let PLAN_NEXT_WEEK_RAW = null;
let PLAN_NEXT_WEEK_VIEW = null;
let PLAN_NEXT_WEEK_LAST_UPDATED = null;
let PLAN_NEXT_WEEK_LOADING = false;
let PLAN_NEXT_WEEK_ERROR = null;

const $planButton = document.getElementById('planNextWeekBtn');
const $planOverlay = document.getElementById('planNextWeekOverlay');
const $planDialog = document.getElementById('planNextWeekDialog');
const $planClose = document.getElementById('planNextWeekClose');
const $planRefresh = document.getElementById('planNextWeekRefresh');
const $planStatus = document.getElementById('planNextWeekStatus');
const $planTable = document.getElementById('planNextWeekTable');
const $planTitle = document.getElementById('planNextWeekTitle');

let __planReturnFocus = null;
let __planPrevBodyOverflow = null;

function planLabel(){
  return PLAN_NEXT_WEEK_SOURCE?.label || 'Plan for Next Week';
}

function planSourceIsConfigured(){
  return Boolean(getPlanSourceUrl());
}

function getPlanSourceUrl(){
  if(PLAN_NEXT_WEEK_SOURCE?.url) return PLAN_NEXT_WEEK_SOURCE.url;
  if(PLAN_NEXT_WEEK_SOURCE?.gid != null && PLAN_NEXT_WEEK_SOURCE.gid !== ''){
    return csvUrlForGid(PLAN_NEXT_WEEK_SOURCE.gid);
  }
  return null;
}

function updatePlanHeaderLabel(){
  if($planTitle) $planTitle.textContent = planLabel();
}

function syncPlanButtons(){
  const configured = planSourceIsConfigured();
  if($planRefresh){
    $planRefresh.disabled = !configured || PLAN_NEXT_WEEK_LOADING;
    if(!configured){
      $planRefresh.title = 'Configure the plan sheet ID/URL to refresh';
    }else if(PLAN_NEXT_WEEK_LOADING){
      $planRefresh.title = 'Loading plan…';
    }else{
      $planRefresh.removeAttribute('title');
    }
  }
  if($planButton){
    if(!configured){
      $planButton.title = 'Configure the plan sheet ID/URL to populate this view';
    }else{
      $planButton.removeAttribute('title');
    }
  }
}

function setPlanStatus(message, state='info'){
  if(!$planStatus) return;
  $planStatus.textContent = message || '';
  $planStatus.dataset.state = state;
}

function isPlanOverlayOpen(){
  return $planOverlay && !$planOverlay.hidden;
}

function focusFirstPlanElement(){
  if(!$planOverlay) return;
  const focusables = Array.from($planOverlay.querySelectorAll(PLAN_FOCUS_SELECTOR))
    .filter(el => el.offsetParent !== null && !el.disabled);
  if(focusables.length){
    focusables[0].focus();
  }else if($planDialog){
    $planDialog.focus();
  }
}

function trapPlanFocus(e){
  if(e.key !== 'Tab' || !isPlanOverlayOpen()) return;
  const focusables = Array.from($planOverlay.querySelectorAll(PLAN_FOCUS_SELECTOR))
    .filter(el => el.offsetParent !== null && !el.disabled);
  if(!focusables.length) return;
  const first = focusables[0];
  const last = focusables[focusables.length - 1];
  if(e.shiftKey && document.activeElement === first){
    e.preventDefault();
    last.focus();
  }else if(!e.shiftKey && document.activeElement === last){
    e.preventDefault();
    first.focus();
  }
}

function handlePlanKeydown(e){
  if(!isPlanOverlayOpen()) return;
  if(e.key === 'Escape'){
    e.preventDefault();
    closePlanOverlay();
  }else if(e.key === 'Tab'){
    trapPlanFocus(e);
  }
}

function openPlanOverlay(){
  if(!$planOverlay || isPlanOverlayOpen()) return;
  __planReturnFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
  __planPrevBodyOverflow = document.body ? document.body.style.overflow : null;
  if(document.body) document.body.style.overflow = 'hidden';
  $planOverlay.hidden = false;
  $planOverlay.setAttribute('aria-hidden','false');
  updatePlanHeaderLabel();
  syncPlanButtons();
  focusFirstPlanElement();
  ensurePlanLoaded();
  document.addEventListener('keydown', handlePlanKeydown, true);
}

function closePlanOverlay(){
  if(!$planOverlay || !isPlanOverlayOpen()) return;
  $planOverlay.hidden = true;
  $planOverlay.setAttribute('aria-hidden','true');
  document.removeEventListener('keydown', handlePlanKeydown, true);
  if(document.body){
    if(__planPrevBodyOverflow != null){
      document.body.style.overflow = __planPrevBodyOverflow;
    }else{
      document.body.style.removeProperty('overflow');
    }
  }
  if(__planReturnFocus && typeof __planReturnFocus.focus === 'function'){
    __planReturnFocus.focus();
  }
  __planReturnFocus = null;
}

if($planOverlay){
  $planOverlay.addEventListener('click', event => {
    if(event.target === $planOverlay){
      closePlanOverlay();
    }
  });
}

if($planButton){
  $planButton.addEventListener('click', () => {
    openPlanOverlay();
  });
}

$planClose?.addEventListener('click', () => closePlanOverlay());
$planRefresh?.addEventListener('click', () => ensurePlanLoaded(true));
updatePlanHeaderLabel();
syncPlanButtons();
setPlanStatus(planSourceIsConfigured() ? 'Plan data has not been loaded yet.' : 'Configure the plan sheet ID/URL to view the schedule.', 'info');

function applyPlanSourceFromIndex(entry){
  if(!entry) return;
  PLAN_NEXT_WEEK_SOURCE.meta = entry;
  if(!PLAN_SOURCE_LOCKED){
    const gid = sanitizePlanScalar(entry.gid);
    const url = sanitizePlanScalar(entry.url);
    if(url){
      PLAN_NEXT_WEEK_SOURCE.url = url;
    }else if(gid){
      PLAN_NEXT_WEEK_SOURCE.gid = gid;
    }
  }
  if(!PLAN_LABEL_LOCKED){
    const lbl = sanitizePlanScalar(entry.label);
    if(lbl) PLAN_NEXT_WEEK_SOURCE.label = lbl;
  }
  updatePlanHeaderLabel();
  syncPlanButtons();
}

function normalizePlanDay(value){
  const raw = sanitizePlanScalar(value);
  if(!raw) return null;
  const slug = slugify(raw);
  if(PLAN_DAY_SLUG_MAP.has(slug)) return PLAN_DAY_SLUG_MAP.get(slug);
  const lower = raw.toLowerCase();
  if(PLAN_DAY_SLUG_MAP.has(lower)) return PLAN_DAY_SLUG_MAP.get(lower);
  const aliasTarget = PLAN_DAY_ALIAS_TARGETS.get(slug) || PLAN_DAY_ALIAS_TARGETS.get(lower);
  if(aliasTarget){
    const aliasSlug = slugify(aliasTarget);
    if(PLAN_DAY_SLUG_MAP.has(aliasSlug)) return PLAN_DAY_SLUG_MAP.get(aliasSlug);
    const aliasLower = String(aliasTarget).toLowerCase();
    if(PLAN_DAY_SLUG_MAP.has(aliasLower)) return PLAN_DAY_SLUG_MAP.get(aliasLower);
  }
  const asDate = new Date(raw);
  if(!Number.isNaN(asDate.getTime())){
    const dayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
    const derived = dayNames[asDate.getDay()];
    const derivedSlug = slugify(derived);
    if(PLAN_DAY_SLUG_MAP.has(derivedSlug)) return PLAN_DAY_SLUG_MAP.get(derivedSlug);
    const derivedLower = derived.toLowerCase();
    if(PLAN_DAY_SLUG_MAP.has(derivedLower)) return PLAN_DAY_SLUG_MAP.get(derivedLower);
  }
  return null;
}

function normalizePlanPerson(value){
  const raw = sanitizePlanScalar(value);
  if(!raw) return null;
  const slug = slugify(raw);
  if(PLAN_PERSON_SLUG_MAP.has(slug)) return PLAN_PERSON_SLUG_MAP.get(slug);
  const lower = raw.toLowerCase();
  if(PLAN_PERSON_SLUG_MAP.has(lower)) return PLAN_PERSON_SLUG_MAP.get(lower);
  const aliasTarget = PLAN_PERSON_ALIAS_TARGETS.get(slug) || PLAN_PERSON_ALIAS_TARGETS.get(lower);
  if(aliasTarget){
    const aliasSlug = slugify(aliasTarget);
    if(PLAN_PERSON_SLUG_MAP.has(aliasSlug)) return PLAN_PERSON_SLUG_MAP.get(aliasSlug);
    const aliasLower = String(aliasTarget).toLowerCase();
    if(PLAN_PERSON_SLUG_MAP.has(aliasLower)) return PLAN_PERSON_SLUG_MAP.get(aliasLower);
  }
  return null;
}

function splitPlanEntries(value){
  if(value == null) return [];
  if(Array.isArray(value)) return value.filter(Boolean);
  const str = String(value).replace(/\r/g,'\n');
  const parts = str.split(/\n+|;;+/).map(part => part.trim()).filter(Boolean);
  return parts.length ? parts : (str.trim() ? [str.trim()] : []);
}

function extractPlanWorkOrderId(raw){
  if(!raw) return null;
  const str = String(raw);
  const match = str.match(/(?:^|\b)WO[-\s#:]*?(\d{3,})\b/i) || str.match(/(?:^|\b)(\d{3,})\b/);
  if(!match) return null;
  return normalizeId(match[1]);
}

function findWorkOrderById(normalizedId, workOrders){
  if(!normalizedId || !Array.isArray(workOrders)) return null;
  return workOrders.find(row => normalizeId(row?.ID) === normalizedId);
}

function buildPlanEntry(rawValue, noteText, context){
  const raw = sanitizePlanScalar(rawValue);
  if(!raw) return null;
  const entry = { raw, note: sanitizePlanScalar(noteText) || null, type:'text', lookupId:null, workOrder:null };
  const id = extractPlanWorkOrderId(raw);
  if(id){
    entry.lookupId = id;
    const match = findWorkOrderById(id, context.workOrders);
    if(match){
      entry.type = 'wo';
      entry.workOrder = match;
    }else{
      entry.type = 'missing';
    }
  }
  return entry;
}

function buildEmptyPlanMatrix(){
  const matrix = new Map();
  PLAN_NEXT_WEEK_DAYS.forEach(day => {
    const inner = new Map();
    PLAN_NEXT_WEEK_PEOPLE.forEach(person => {
      inner.set(person, []);
    });
    matrix.set(day, inner);
  });
  return matrix;
}

function mergePlanOrder(primary, fallback){
  const merged = [];
  const seen = new Set();
  const add = value => {
    if(value == null) return;
    if(seen.has(value)) return;
    seen.add(value);
    merged.push(value);
  };
  if(Array.isArray(primary)) primary.forEach(add);
  if(Array.isArray(fallback)) fallback.forEach(add);
  return merged;
}

function buildPlanView(raw, context){
  const headers = Array.isArray(raw?.headers) ? raw.headers : [];
  const rows = Array.isArray(raw?.rows) ? raw.rows : [];
  const stats = {
    totalRows: rows.length,
    appliedEntries: 0,
    skippedRows: 0,
    unknownDays: new Set(),
    unknownPeople: new Set(),
    unmatchedWorkOrders: 0,
  };
  const headerLookup = headers.map(h => String(h || '').trim());
  const findHeader = (...candidates) => {
    const wanted = candidates.map(c => String(c).trim().toLowerCase());
    const idx = headerLookup.findIndex(h => wanted.includes(h.toLowerCase()));
    return idx >= 0 ? headers[idx] : null;
  };
  const findHeaders = (...candidates) => {
    const wanted = new Set(candidates.map(c => String(c).trim().toLowerCase()).filter(Boolean));
    if(!wanted.size) return [];
    const matches = [];
    headerLookup.forEach((h, idx) => {
      if(wanted.has(h.toLowerCase())) matches.push(headers[idx]);
    });
    return matches;
  };
  const H_DAY = findHeader('day', 'weekday', 'week day', 'date', 'plan day');
  const H_PERSON = findHeader('person', 'engineer', 'name', 'assigned to', 'team', 'staff');
  const H_ENTRY_ALL = findHeaders('entry', 'item', 'task', 'work order', 'wo', 'details', 'description', 'text');
  const H_NOTES = findHeader('notes', 'note', 'comment', 'comments', 'extra');
  const issues = [];
  if(!H_DAY) issues.push('Day');
  if(!H_PERSON) issues.push('Engineer');
  if(!H_ENTRY_ALL.length && !H_NOTES) issues.push('Entry');
  const matrix = buildEmptyPlanMatrix();
  const order = { days: [], people: [] };
  if(issues.length){
    return { matrix, stats, issues, columns:{ day:H_DAY, person:H_PERSON, entry:H_ENTRY_ALL, notes:H_NOTES }, order };
  }
  const seenDays = new Set();
  const seenPeople = new Set();
  rows.forEach((row, rowIndex) => {
    const rawDay = H_DAY ? row?.[H_DAY] : null;
    const day = normalizePlanDay(rawDay);
    if(!day){
      if(rawDay) stats.unknownDays.add(String(rawDay));
      stats.skippedRows += 1;
      return;
    }
    const rawPerson = H_PERSON ? row?.[H_PERSON] : null;
    const person = normalizePlanPerson(rawPerson);
    if(!person){
      if(rawPerson) stats.unknownPeople.add(String(rawPerson));
      stats.skippedRows += 1;
      return;
    }
    if(!seenDays.has(day)){
      seenDays.add(day);
      order.days.push(day);
    }
    if(!seenPeople.has(person)){
      seenPeople.add(person);
      order.people.push(person);
    }
    const entryValues = H_ENTRY_ALL.flatMap(header => splitPlanEntries(row?.[header]));
    const noteValue = H_NOTES ? row?.[H_NOTES] : null;
    const noteText = sanitizePlanScalar(noteValue);
    const values = entryValues
      .map(val => (typeof val === 'string' ? val.trim() : val))
      .filter(val => {
        if(!val) return false;
        if(noteText && isPlanNotePlaceholder(val)) return false;
        return true;
      });
    const entriesToProcess = values;
    const noteForEntries = values.length ? noteText : null;
    let added = 0;
    entriesToProcess.forEach((val, entryIndex) => {
      const entry = buildPlanEntry(val, noteForEntries, context);
      if(!entry) return;
      if(entry.type === 'missing') stats.unmatchedWorkOrders += 1;
      entry.__meta = {
        rowIndex,
        entryIndex,
        day,
        person,
      };
      matrix.get(day)?.get(person)?.push(entry);
      stats.appliedEntries += 1;
      added += 1;
    });
    if(!added){
      stats.skippedRows += 1;
    }
  });
  return {
    matrix,
    stats,
    issues,
    columns:{ day:H_DAY, person:H_PERSON, entry:H_ENTRY_ALL, notes:H_NOTES },
    order:{
      days: mergePlanOrder(order.days, PLAN_NEXT_WEEK_DAYS),
      people: mergePlanOrder(order.people, PLAN_NEXT_WEEK_PEOPLE),
    }
  };
}

function formatPlanTimestamp(date){
  if(!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
  try{
    return new Intl.DateTimeFormat(undefined, { dateStyle:'medium', timeStyle:'short' }).format(date);
  }catch{
    return date.toISOString();
  }
}

function planStatsSummary(stats){
  if(!stats) return '';
  const parts = [];
  const applied = stats.appliedEntries || 0;
  parts.push(`${applied} entr${applied === 1 ? 'y' : 'ies'}`);
  if(stats.unmatchedWorkOrders){
    const label = stats.unmatchedWorkOrders === 1 ? 'WO not found' : 'WOs not found';
    parts.push(`${stats.unmatchedWorkOrders} ${label}`);
  }
  const skippedDetails = [];
  if(stats.unknownDays && stats.unknownDays.size){
    skippedDetails.push(`unknown day: ${Array.from(stats.unknownDays).join(', ')}`);
  }
  if(stats.unknownPeople && stats.unknownPeople.size){
    skippedDetails.push(`unknown engineer: ${Array.from(stats.unknownPeople).join(', ')}`);
  }
  if(stats.skippedRows){
    skippedDetails.push(`${stats.skippedRows} row${stats.skippedRows === 1 ? '' : 's'} skipped`);
  }
  if(skippedDetails.length){
    parts.push(`Skipped (${skippedDetails.join('; ')})`);
  }
  return parts.join(' • ');
}

function splitTaskTitleSuffix(text){
  const raw = typeof text === 'string' ? text : (text == null ? '' : String(text));
  const normalized = raw.replace(/\s+/g, ' ').trim();
  if(!normalized) return { main:'', suffix:null };
  const suffixMatch = normalized.match(/\s[-–—]\s?[A-Za-z]{1,5}$/);
  if(suffixMatch){
    return {
      main: normalized.slice(0, suffixMatch.index).trimEnd(),
      suffix: suffixMatch[0].trim()
    };
  }
  return { main: normalized, suffix:null };
}

function createTaskCardTitle(text){
  const { main, suffix } = splitTaskTitleSuffix(text);
  const el = document.createElement('div');
  el.className = 'task-card__title';
  const mainText = main || (typeof text === 'string' ? text.trim() : String(text ?? ''));
  el.appendChild(document.createTextNode(mainText));
  if(suffix){
    el.appendChild(document.createTextNode(' '));
    const suffixEl = document.createElement('span');
    suffixEl.className = 'task-card__suffix';
    suffixEl.textContent = suffix;
    el.appendChild(suffixEl);
  }
  return el;
}

function planEntryPresentationType(entry){
  if(!entry) return 'text';
  if(entry.type === 'note') return 'note';
  if(entry.type === 'missing') return 'missing';
  if(entry.type === 'wo') return 'wo';
  const rawLabel = typeof entry.raw === 'string' ? entry.raw.trim().toLowerCase() : '';
  if(rawLabel && (rawLabel === 'note' || rawLabel === 'notes')) return 'note';
  return entry.type || 'text';
}

function deriveTaskCardVariant(entry, entryType){
  if(!entry) return 'scheduled';
  const type = entryType || planEntryPresentationType(entry);
  if(type === 'note') return 'note';
  if(type === 'missing') return 'critical';
  if(type === 'text') return 'scheduled';
  const statusSlug = entry.workOrder ? slugify(String(entry.workOrder.Status ?? entry.workOrder.status ?? '')) : '';
  const prioritySlug = entry.workOrder ? slugify(String(entry.workOrder.Priority ?? entry.workOrder.priority ?? '')) : '';
  if(statusSlug.includes('hold')) return 'hold';
  if(prioritySlug.includes('critical') || prioritySlug.includes('urgent') || statusSlug.includes('critical') || statusSlug.includes('urgent')){
    return 'critical';
  }
  return 'scheduled';
}

function planCardChipLabel(entry, entryType){
  if(!entry) return null;
  const type = entryType || planEntryPresentationType(entry);
  if(type === 'note') return 'NOTE';

  const idCandidate = entry.lookupId || entry.workOrder?.ID;
  if(idCandidate){
    const match = String(idCandidate).match(/\d{3,}/);
    if(match) return `WO ${match[0]}`;
  }

  if(entry.type === 'text'){
    const rawText = typeof entry.raw === 'string' ? entry.raw.trim() : (entry.raw != null ? String(entry.raw).trim() : '');
    if(rawText){
      const maxLength = 24;
      return rawText.length > maxLength ? `${rawText.slice(0, maxLength - 1).trimEnd()}…` : rawText;
    }
    return 'PLAN';
  }

  const candidate = entry.lookupId || entry.workOrder?.ID || entry.raw;
  if(!candidate) return 'PLAN';
  const match = String(candidate).match(/\d{3,}/);
  return match ? `WO ${match[0]}` : String(candidate).trim().toUpperCase();
}

function renderPlanEntry(entry){
  const card = document.createElement('div');
  card.className = 'task-card';
  const entryType = planEntryPresentationType(entry);
  card.dataset.type = entryType;
  card.dataset.variant = deriveTaskCardVariant(entry, entryType);
  card.tabIndex = 0;

  const chipLabel = planCardChipLabel(entry, entryType);
  if(chipLabel){
    const chipRow = document.createElement('div');
    chipRow.className = 'task-card__chip-row';
    const chip = document.createElement('span');
    chip.className = 'task-card__chip';
    chip.textContent = chipLabel;
    chipRow.appendChild(chip);
    card.appendChild(chipRow);
  }

  const body = document.createElement('div');
  body.className = 'task-card__body';
  const titleSource = entry.type === 'wo' ? (entry.workOrder?.Title || entry.raw) : entry.raw;
  body.appendChild(createTaskCardTitle(titleSource));

  if(entry.type === 'missing'){
    const meta = document.createElement('div');
    meta.className = 'task-card__meta';
    meta.textContent = 'Work order not found';
    body.appendChild(meta);
  }

  if(entry.note){
    const note = document.createElement('div');
    note.className = 'task-card__note';
    note.textContent = entry.note;
    body.appendChild(note);
  }

  card.appendChild(body);
  return card;
}

function comparePlanEntryOrder(a, b){
  const aMeta = a?.__meta || {};
  const bMeta = b?.__meta || {};
  const aRow = Number.isFinite(aMeta.rowIndex) ? aMeta.rowIndex : Number.MAX_SAFE_INTEGER;
  const bRow = Number.isFinite(bMeta.rowIndex) ? bMeta.rowIndex : Number.MAX_SAFE_INTEGER;
  if(aRow !== bRow) return aRow - bRow;
  const aIdx = Number.isFinite(aMeta.entryIndex) ? aMeta.entryIndex : Number.MAX_SAFE_INTEGER;
  const bIdx = Number.isFinite(bMeta.entryIndex) ? bMeta.entryIndex : Number.MAX_SAFE_INTEGER;
  if(aIdx !== bIdx) return aIdx - bIdx;
  return String(a?.raw ?? '').localeCompare(String(b?.raw ?? ''), undefined, { numeric:true, sensitivity:'base' });
}

function renderPlanTable(view){
  if(!$planTable) return;
  $planTable.innerHTML = '';
  if(!planSourceIsConfigured()){
    setPlanStatus('Configure the plan sheet ID/URL to view the schedule.', 'info');
    return;
  }
  if(!view){
    setPlanStatus('Plan data has not been loaded yet.', 'info');
    return;
  }
  if(view.issues && view.issues.length){
    setPlanStatus(`Plan sheet is missing required column(s): ${view.issues.join(', ')}`, 'error');
    return;
  }
  const dayOrder = mergePlanOrder(view.order?.days, PLAN_NEXT_WEEK_DAYS);
  const peopleOrder = mergePlanOrder(view.order?.people, PLAN_NEXT_WEEK_PEOPLE);
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  const thBlank = document.createElement('th');
  thBlank.scope = 'col';
  thBlank.textContent = 'Engineer';
  headerRow.appendChild(thBlank);
  dayOrder.forEach(day => {
    const th = document.createElement('th');
    th.scope = 'col';
    th.textContent = day;
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  const tbody = document.createElement('tbody');
  peopleOrder.forEach(person => {
    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.scope = 'row';
    th.textContent = person;
    tr.appendChild(th);
    dayOrder.forEach(day => {
      const td = document.createElement('td');
      const dayBucket = view.matrix.get(day);
      const entries = dayBucket?.get(person) || [];
      const sortedEntries = entries.length > 1 ? entries.slice().sort(comparePlanEntryOrder) : entries;
      if(sortedEntries.length){
        sortedEntries.forEach(entry => td.appendChild(renderPlanEntry(entry)));
      }else{
        const empty = document.createElement('div');
        empty.className = 'plan-empty';
        empty.textContent = 'No plan';
        td.appendChild(empty);
      }
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  $planTable.appendChild(thead);
  $planTable.appendChild(tbody);
  const statusParts = [];
  statusParts.push(planLabel());
  const summary = planStatsSummary(view.stats);
  if(summary) statusParts.push(summary);
  if(PLAN_NEXT_WEEK_LAST_UPDATED){
    statusParts.push(`Updated ${formatPlanTimestamp(PLAN_NEXT_WEEK_LAST_UPDATED)}`);
  }
  setPlanStatus(statusParts.join(' • '), 'ready');
  if(window.__planNextWeekNoteStyler__ && typeof window.__planNextWeekNoteStyler__.apply === 'function'){
    try{
      window.__planNextWeekNoteStyler__.apply();
    }catch{}
  }
}

// 1) css string
const css = `
:root{
  --card-bg:color-mix(in srgb, var(--paper, #ffffff) 96%, var(--bg, #f3f5f9));
  --card-border:color-mix(in srgb, var(--border, #e5e9f2) 70%, transparent);
  --card-shadow-rest:0 1px 2px rgba(15,23,42,.08),0 4px 10px rgba(15,23,42,.06);
  --card-shadow-hover:0 6px 18px rgba(15,23,42,.14),0 4px 12px rgba(15,23,42,.08);
  --chip-bg:color-mix(in srgb, var(--brand, #0b67c2) 12%, var(--paper, #ffffff));
  --chip-ink:color-mix(in srgb, var(--brand, #0b67c2) 36%, var(--ink, #0b0f1a));
  --accent-blue:#2563eb;
  --accent-amber:#f59e0b;
  --accent-red:#ef4444;
  --accent-grey:#6b7280;
}
@media (prefers-color-scheme: dark){
  :root{
    --card-bg:color-mix(in srgb, var(--paper, #131a2b) 94%, var(--bg, #0f1422));
    --card-border:color-mix(in srgb, var(--border, #233150) 80%, transparent);
    --card-shadow-rest:0 1px 2px rgba(0,0,0,.48),0 4px 12px rgba(0,0,0,.42);
    --card-shadow-hover:0 6px 20px rgba(0,0,0,.55),0 3px 12px rgba(0,0,0,.5);
    --chip-bg:color-mix(in srgb, var(--brand, #3b82f6) 16%, var(--paper, #131a2b));
    --chip-ink:color-mix(in srgb, var(--brand, #3b82f6) 60%, var(--ink, #f3f4f6));
    --accent-blue:#60a5fa;
    --accent-amber:#fbbf24;
    --accent-red:#f87171;
    --accent-grey:#9ca3af;
  }
}
#plan-next-week{
  --plan-card-bg:var(--paper);
  --plan-card-text:#0b0f1a;
  --plan-card-border:color-mix(in srgb, var(--grid) 65%, transparent);
}
@media (prefers-color-scheme: dark){
  #plan-next-week{
    --plan-card-bg:color-mix(in srgb, var(--paper) 94%, transparent);
    --plan-card-text:#0b0f1a;
    --plan-card-border:color-mix(in srgb, #1f2937 55%, transparent);
  }
}
#plan-next-week .task-card{
  position:relative;
  display:flex;
  flex-direction:column;
  gap:6px;
  padding:8px 12px 8px 16px;
  min-height:0;
  border-radius:6px;
  border:1px solid var(--plan-card-border);
  background:var(--plan-card-bg);
  box-shadow:none;
  color:var(--plan-card-text);
  line-height:1.4;
  transition:border-color .18s ease;
  word-break:break-word;
  overflow-wrap:anywhere;
  outline:0;
}
#plan-next-week .task-card::before{
  content:"";
  position:absolute;
  left:0;
  top:8px;
  bottom:8px;
  width:3px;
  border-radius:999px;
  background:var(--accent-blue);
}
#plan-next-week .task-card[data-variant="note"]{
  background:color-mix(in srgb, var(--plan-card-bg) 65%, var(--bg));
  color:color-mix(in srgb, var(--muted) 75%, var(--plan-card-text));
}
#plan-next-week .task-card[data-variant="scheduled"]::before,
#plan-next-week .task-card[data-variant="note"]::before{
  content:none;
}
#plan-next-week .task-card[data-variant="hold"]::before{background:var(--accent-amber);}
#plan-next-week .task-card[data-variant="critical"]::before{background:var(--accent-red);}
#plan-next-week .task-card + .task-card{margin-top:8px;}
#plan-next-week .task-card:focus-visible{
  outline:2px solid color-mix(in srgb, var(--brand, #0b67c2) 55%, transparent);
  outline-offset:2px;
}
#plan-next-week .task-card:hover{
  border-color:color-mix(in srgb, var(--plan-card-border) 55%, var(--brand, #0b67c2) 45%);
}
#plan-next-week .task-card.is-dragging,
#plan-next-week .task-card[data-dragging="true"]{
  border-style:dashed;
  border-color:color-mix(in srgb, var(--plan-card-border) 70%, transparent);
}
#plan-next-week .task-card__chip-row{
  display:flex;
  align-items:center;
  gap:8px;
  margin:4px 0 0;
  min-height:0;
}
#plan-next-week .task-card__chip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:2px 10px;
  border-radius:999px;
  border:1px solid color-mix(in srgb, var(--plan-card-border) 70%, transparent);
  background:transparent;
  color:color-mix(in srgb, var(--plan-card-text) 75%, var(--muted) 25%);
  font-size:12px;
  font-weight:600;
  text-transform:uppercase;
  letter-spacing:.04em;
}
#plan-next-week .task-card__body{
  display:flex;
  flex-direction:column;
  gap:6px;
  min-height:0;
}
#plan-next-week .task-card__title{
  font-size:14.5px;
  font-weight:600;
  line-height:1.4;
  color:var(--plan-card-text);
  display:-webkit-box;
  -webkit-line-clamp:3;
  -webkit-box-orient:vertical;
  overflow:hidden;
  text-overflow:ellipsis;
}
#plan-next-week .task-card__suffix{color:color-mix(in srgb, var(--plan-card-text) 65%, var(--muted) 35%);font-weight:500;}
#plan-next-week .task-card__meta,
#plan-next-week .task-card__note{
  font-size:13px;
  color:color-mix(in srgb, var(--plan-card-text) 65%, var(--muted) 35%);
}
#plan-next-week .task-card__note{margin-top:2px;}
`;

// 2) injection + DOM pass (safe, idempotent)
(function styleWOAndNotes(){
  const STATE_KEY = '__planNextWeekNoteStyler__';
  const STYLE_ID = 'plan-next-week-style';
  const BADGE_REGEX = /\bWO\s*\d{3,6}\b/i;
  const raf = window.requestAnimationFrame?.bind(window) || function(cb){ return setTimeout(cb, 16); };

  if(window[STATE_KEY]){
    if(typeof window[STATE_KEY].apply === 'function'){
      window[STATE_KEY].apply();
    }
    return;
  }

  const state = {
    scheduled:false,
    root:null,
    rootObserver:null,
    docObserver:null,
    apply:applyNow,
  };

  window[STATE_KEY] = state;

  ensureStyle();
  const initialRoot = ensureRoot();
  if(initialRoot){
    state.root = initialRoot;
    applyNow();
    observeRoot(initialRoot);
  }else{
    observeDocument();
  }

  function ensureStyle(){
    if(document.getElementById(STYLE_ID)) return;
    const style = document.createElement('style');
    style.id = STYLE_ID;
    style.textContent = css;
    (document.head || document.documentElement).appendChild(style);
  }

  function ensureRoot(){
    const heading = Array.from(document.querySelectorAll('h1,h2,h3,h4,h5,h6')).find(el => el.textContent && el.textContent.trim() === 'Plan for Next Week');
    if(!heading) return null;
    const panel = heading.closest('[role="dialog"]') || heading.closest('section,div,article') || heading.parentElement;
    if(panel && panel.id !== 'plan-next-week'){
      if(panel.id){
        panel.setAttribute('data-plan-prev-id', panel.id);
      }
      panel.id = 'plan-next-week';
    }
    return panel || null;
  }

  function observeDocument(){
    if(state.docObserver || !document.body) return;
    const observer = new MutationObserver(() => {
      const root = ensureRoot();
      if(root){
        state.root = root;
        applyNow();
        observeRoot(root);
        observer.disconnect();
        state.docObserver = null;
      }
    });
    observer.observe(document.body, { childList:true, subtree:true });
    state.docObserver = observer;
  }

  function observeRoot(root){
    if(state.rootObserver){
      state.rootObserver.disconnect();
    }
    const observer = new MutationObserver(mutations => {
      for(const mutation of mutations){
        if(mutation.type === 'childList'){
          scheduleApply();
          break;
        }
      }
    });
    observer.observe(root, { childList:true, subtree:true });
    state.rootObserver = observer;
  }

  function scheduleApply(){
    if(state.scheduled) return;
    state.scheduled = true;
    raf(() => {
      state.scheduled = false;
      applyNow();
    });
  }

  function applyNow(){
    const root = ensureRoot();
    if(!root) return;
    state.root = root;
    processRoot(root);
  }

  function processRoot(root){
    const cells = root.querySelectorAll('td');
    cells.forEach(cell => {
      processCandidate(cell);
      Array.from(cell.children).forEach(child => processCandidate(child));
    });
  }

  function processCandidate(element){
    if(!(element instanceof HTMLElement)) return;
    if(element.classList.contains('task-card')) return;

    const textContent = element.textContent || '';
    const trimmed = textContent.trim();
    if(!trimmed || trimmed === 'No plan') return;

    if(BADGE_REGEX.test(trimmed)){
      convertWorkOrder(element);
    }else if(element.childElementCount <= 1 && trimmed.length <= 48 && !BADGE_REGEX.test(textContent) && !/[\r\n]/.test(textContent) && trimmed.replace(/\s+/g,' ').split(' ').length <= 8){
      convertNote(element, trimmed);
    }
  }

  function normalizeBadge(raw){
    if(!raw) return 'WO';
    const digitsMatch = raw.match(/\d{3,6}/);
    if(digitsMatch){
      return `WO ${digitsMatch[0]}`;
    }
    return raw.replace(/\s+/g,' ').trim().toUpperCase();
  }

  function convertWorkOrder(element){
    if(element.classList.contains('task-card')) return;
    const fullText = element.textContent || '';
    const badgeMatch = fullText.match(BADGE_REGEX);
    if(!badgeMatch) return;

    const elements = Array.from(element.children);
    const badgeSource = elements.find(child => BADGE_REGEX.test(child.textContent || '')) || null;
    const badgeIndex = badgeSource ? elements.indexOf(badgeSource) : -1;
    let titleSource = null;
    if(badgeIndex > -1){
      for(let i = badgeIndex + 1; i < elements.length; i += 1){
        const nextText = elements[i].textContent;
        if(nextText && nextText.trim()){
          titleSource = elements[i];
          break;
        }
      }
    }

    const preserveNodes = [];
    Array.from(element.childNodes).forEach(node => {
      if(node !== badgeSource && node !== titleSource){
        preserveNodes.push(node);
      }
    });

    const fragment = document.createDocumentFragment();
    preserveNodes.forEach(node => fragment.appendChild(node));

    let titleText = titleSource ? (titleSource.textContent || '').trim() : '';
    if(!titleText){
      const remainder = badgeMatch ? fullText.replace(badgeMatch[0], '').trim() : '';
      const lines = remainder.split(/\r?\n+/).map(line => line.trim()).filter(Boolean);
      titleText = lines.shift() || remainder || 'Work order';
    }

    element.innerHTML = '';
    element.className = 'task-card';
    element.dataset.type = 'wo';
    element.dataset.variant = detectVariantFromFragment(fragment, fullText);
    element.setAttribute('tabindex','0');

    const chipRow = document.createElement('div');
    chipRow.className = 'task-card__chip-row';
    const chip = document.createElement('span');
    chip.className = 'task-card__chip';
    chip.textContent = normalizeBadge(badgeMatch[0]);
    chipRow.appendChild(chip);
    element.appendChild(chipRow);

    const body = document.createElement('div');
    body.className = 'task-card__body';
    body.appendChild(createTaskCardTitle(titleText));

    const detailText = fragment.textContent ? fragment.textContent.replace(/\s+/g,' ').trim() : '';
    if(fragment.childNodes.length && detailText){
      const meta = document.createElement('div');
      meta.className = 'task-card__meta';
      meta.appendChild(fragment);
      body.appendChild(meta);
    }

    element.appendChild(body);
  }

  function convertNote(element, text){
    if(element.classList.contains('task-card')) return;

    element.innerHTML = '';
    element.className = 'task-card';
    element.dataset.type = 'note';
    element.dataset.variant = 'note';
    element.setAttribute('tabindex','0');

    const chipRow = document.createElement('div');
    chipRow.className = 'task-card__chip-row';
    const chip = document.createElement('span');
    chip.className = 'task-card__chip';
    chip.textContent = 'NOTE';
    chipRow.appendChild(chip);
    element.appendChild(chipRow);

    const body = document.createElement('div');
    body.className = 'task-card__body';
    body.appendChild(createTaskCardTitle(text));
    element.appendChild(body);
  }

  function detectVariantFromFragment(fragment, fallbackText){
    const fragmentText = fragment?.textContent || '';
    const combined = `${fragmentText} ${fallbackText || ''}`;
    const slug = slugify(combined || '');
    if(!slug) return 'scheduled';
    if(slug.includes('hold')) return 'hold';
    if(slug.includes('critical') || slug.includes('urgent') || slug.includes('emergency')) return 'critical';
    return 'scheduled';
  }
})();

// 3) // Optional: Tampermonkey wrapper (commented out)
// (function(){
//   // ==UserScript==
//   // @name         Plan Next Week Card Restyle
//   // @namespace    http://tampermonkey.net/
//   // @version      1.0
//   // @description  Restyle Plan for Next Week cards
//   // @match        *
//   // @grant        none
//   // ==/UserScript==
//   // styleWOAndNotes();
// })();

function rebuildPlanView(){
  if(!PLAN_NEXT_WEEK_RAW){
    PLAN_NEXT_WEEK_VIEW = null;
    return;
  }
  PLAN_NEXT_WEEK_VIEW = buildPlanView(PLAN_NEXT_WEEK_RAW, { workOrders: Array.isArray(ALL_ROWS) ? ALL_ROWS : [] });
  if(isPlanOverlayOpen()){
    renderPlanTable(PLAN_NEXT_WEEK_VIEW);
  }
}

async function loadPlanNextWeek(force=false){
  if(PLAN_NEXT_WEEK_LOADING && !force) return PLAN_NEXT_WEEK_RAW;
  const urlBase = getPlanSourceUrl();
  if(!urlBase){
    throw new Error('Plan sheet is not configured.');
  }
  PLAN_NEXT_WEEK_LOADING = true;
  PLAN_NEXT_WEEK_ERROR = null;
  syncPlanButtons();
  try{
    const url = force ? withBust(urlBase) : urlBase;
    const res = await fetch(url);
    if(!res.ok){
      throw new Error(`Could not load plan sheet (${res.status} ${res.statusText})`);
    }
    const text = await res.text();
    if(!text || !text.trim()){
      throw new Error('Plan sheet is empty.');
    }
    const parsed = parseDelimited(text);
    PLAN_NEXT_WEEK_RAW = { headers: parsed.headers, rows: parsed.rows };
    PLAN_NEXT_WEEK_LAST_UPDATED = new Date();
    rebuildPlanView();
    return PLAN_NEXT_WEEK_RAW;
  } finally {
    PLAN_NEXT_WEEK_LOADING = false;
    syncPlanButtons();
  }
}

async function ensurePlanLoaded(force=false){
  if(!planSourceIsConfigured()){
    setPlanStatus('Configure the plan sheet ID/URL to view the schedule.', 'info');
    return;
  }
  try{
    setPlanStatus('Loading plan…', 'loading');
    await loadPlanNextWeek(force);
    renderPlanTable(PLAN_NEXT_WEEK_VIEW);
  } catch(err){
    PLAN_NEXT_WEEK_ERROR = err;
    if($planTable) $planTable.innerHTML = '';
    setPlanStatus(err?.message || 'Could not load plan data.', 'error');
  }
}

function refreshPlanWithWorkOrders(){
  rebuildPlanView();
}

function isPlanLabel(label){
  const slug = slugify(String(label || ''));
  return slug === 'plan-next-week' || slug === 'next-week-plan' || slug === 'plan-for-next-week';
}

/* --- Parse the Index (label, week_end, gid) with aliases + diagnostics --- */
async function loadWeeksIndex(){
  return loadWeeksIndexFrom(SHEET_INDEX_CSV_URL);
}

async function loadWeeksIndexFrom(url){
    console.log('Index CSV URL:', url);   // 👈 add here
  const res = await fetch(url);
  if(!res.ok) throw new Error('Index load failed: ' + res.status);

  const text = await res.text();
  const { headers, rows } = parseDelimited(text);

  // Normalize headers once
  const normHeaders = headers.map(h => String(h || '').trim());
  const findHeader = (...candidates) => {
    const wanted = candidates.map(c => String(c).trim().toLowerCase());
    const idx = normHeaders.findIndex(h => wanted.includes(h.toLowerCase()));
    return idx >= 0 ? headers[idx] : null;
  };

  // Accept common aliases
  const H_LABEL   = findHeader('label', 'week label', 'title', 'name');
  const H_WEEKEND = findHeader('week_end', 'week end', 'week', 'weekending', 'week-ending', 'week_end_date', 'date', 'week ending (iso)');
  const H_GID     = findHeader('gid', 'sheet_gid', 'tab_gid', 'tab id', 'sheet id', 'sheetid', 'tabid', 'sheet');

  // Optional URL column (we can extract gid=12345 from it)
  const H_URL     = findHeader('url', 'sheet url', 'link');

  if (!H_GID && !H_URL){
    console.error('[Index] Headers present:', headers);
    throw new Error('Index is missing a "gid" or "url" column');
  }
  if (!H_LABEL || !H_WEEKEND){
    console.warn('[Index] Using partial headers. Found:', { H_LABEL, H_WEEKEND, H_GID, H_URL, headers });
  }

  const gidFromUrl = (u) => {
    if (!u) return null;
    // Handles ...edit#gid=123, ...pub?gid=123, etc.
    const m = String(u).match(/[?#&]gid=(\d+)/);
    return m ? m[1] : null;
  };

const out = rows.map(r => {
  const label   = H_LABEL   ? r[H_LABEL]   : (r[H_WEEKEND] || '').trim();
  const weekEnd = H_WEEKEND ? r[H_WEEKEND] : '';
  const urlRaw  = H_URL ? String(r[H_URL] || '').trim() : '';
  let gid       = H_GID ? r[H_GID] : null;
  if (!gid && urlRaw) gid = gidFromUrl(urlRaw);
  const url     = urlRaw || null;     // keep the URL if provided
  return { label, weekEnd, gid, url };
}).filter(x => x && (x.gid || x.url));

  if (!out.length){
    console.error('[Index] No usable rows. Headers:', headers, 'Sample row:', rows[0]);
    throw new Error('Index has no rows with a gid');
  }

  const planRows = [];
  const weekRows = [];
  out.forEach(entry => {
    if(isPlanLabel(entry.label)){
      planRows.push(entry);
    }else{
      weekRows.push(entry);
    }
  });

  if(planRows.length){
    applyPlanSourceFromIndex(planRows[0]);
  }

  // newest first by week_end (string compare ok if YYYY-MM-DD)
  weekRows.sort((a,b) => String(b.weekEnd).localeCompare(String(a.weekEnd)));
  return weekRows;
}

/* --- Selection + persistence --- */
const LS_LAST_WEEK = 'alsLastWeekEnd';
function getUrlParam(n){ return new URLSearchParams(location.search).get(n); }
function rememberWeek(w){ try{ localStorage.setItem(LS_LAST_WEEK, w.weekEnd); }catch{} }

function chooseInitialWeek(weeks){
  const q = new URLSearchParams(location.search);
  const byGid  = q.get('gid');
  const byDate = q.get('week');
  const forceLatest = q.get('latest') === '1';

  let chosen = null;
  if (byGid)   chosen = weeks.find(w => String(w.gid) === String(byGid));
  if (!chosen && byDate) chosen = weeks.find(w => String(w.weekEnd) === String(byDate));
  if (!chosen && !forceLatest){
    const last = localStorage.getItem(LS_LAST_WEEK);
    if (last) chosen = weeks.find(w => String(w.weekEnd) === last);
  }
  return chosen || weeks[0]; // newest
}

function setWeekBadge(text){
  const badge = getWeekBadge();
  if(!badge) return;
  badge.hidden = false;
  badge.dataset.state = 'ready';
  badge.textContent = `Week: ${text || 'Latest'}`;
}

function normalizePriority(v){ if(v==null) return ''; let slug=slugify(String(v).trim()); if(!slug) return''; if(slug.endsWith('-priority')) slug=slug.replace(/-priority$/,''); if(slug==='med'||slug==='normal') slug='medium'; if(slug==='urgent'||slug==='emergency') slug='critical'; return slug; }
function cmpPriority(a,b){ const ia=PRIORITY_ORDER.indexOf(normalizePriority(a)), ib=PRIORITY_ORDER.indexOf(normalizePriority(b)); const safe=i=>(i===-1?PRIORITY_ORDER.length:i); const diff=safe(ia)-safe(ib); return diff||String(a??'').localeCompare(String(b??''),undefined,{numeric:true,sensitivity:'base'}); }
function statusClass(v){ const map=new Map([['done','done'],['complete','done'],['completed','done'],['open','open'],['in-progress','in-progress'],['in progress','in-progress'],['progress','in-progress'],['inprogress','in-progress'],['on-hold','on-hold'],['on hold','on-hold'],['hold','on-hold'],['onhold','on-hold']]); const s=slugify(String(v||'')); return map.get(s)||s; }
function cmpStatus(a,b){ const ia=STATUS_ORDER.indexOf(statusClass(a)), ib=STATUS_ORDER.indexOf(statusClass(b)); const safe=i=>(i===-1?STATUS_ORDER.length:i); const diff=safe(ia)-safe(ib); return diff||String(a??'').localeCompare(String(b??''),undefined,{numeric:true,sensitivity:'base'}); }
function cmpId(a,b){ const na=parseInt(String(a).replace(/\D+/g,''),10)||0; const nb=parseInt(String(b).replace(/\D+/g,''),10)||0; return na-nb; }
function detectType(col, rows){
  const n = String(col || '').trim().toLowerCase();

  // 👇 early exit for our virtual Age column
  if (n === 'age' || n === 'age (days)') return 'number';

  const sample = rows.slice(0, 10).map(r => r[col]);
  const allDates = sample.length && sample.every(v => parseDateLoose(v) !== null);
  const allNums  = sample.length && sample.every(v =>
    typeof v === 'number' || /^\s*[-+]?\d+(\.\d+)?\s*$/.test(String(v))
  );

  if (allDates)  return 'date';
  if (allNums)   return 'number';
  if (n === 'id')       return 'id';
  if (n === 'priority') return 'priority';
  if (n === 'status')   return 'status';
  return 'string';
}

// ---------- Shared sort + UI helpers ----------
function applySort(rows, column, direction){
  const list = Array.isArray(rows) ? rows : [];
  if (!column) return list.slice();

  const dir = direction === 'asc' ? 'asc' : 'desc';
  const f   = dir === 'asc' ? 1 : -1;

  // --- Special-case: Age column
  if (String(column).toLowerCase().startsWith('age')) {
    const MIN = -1; // pushes unknowns to the top/bottom depending on dir
    const toMs = (row) => {
      // 1) preferred: precomputed raw ms
      if (row.__ageMs != null) return row.__ageMs;

      const v = row[column];

      // 2) numeric age (e.g. "Age (days)" as number)
      if (typeof v === 'number' && Number.isFinite(v)) {
        return v * 24 * 60 * 60 * 1000;
      }
      // 3) human string like "14d 6h 3m"
      if (typeof v === 'string' && v.trim()){
        const m = v.match(/^\s*(?:(\d+)\s*d)?\s*(?:(\d+)\s*h)?\s*(?:(\d+)\s*m)?\s*$/i);
        if (m && (m[1] || m[2] || m[3])) {
          const d  = +m[1] || 0;
          const h  = +m[2] || 0;
          const mm = +m[3] || 0;
          return (((d * 24) + h) * 60 + mm) * 60 * 1000;
        }
        // also accept plain numeric strings as days
        if (/^\s*[-+]?\d+(\.\d+)?\s*$/.test(v)) {
          return parseFloat(v) * 24 * 60 * 60 * 1000;
        }
      }
      // 4) fallback: compute from "Created on"
      const created = parseDateLoose(row['Created on']);
      return created ? (Date.now() - created.getTime()) : MIN;
    };

    return [...list].sort((a,b) => f * (toMs(a) - toMs(b)));
  }

  // --- normal types
  const type = detectType(column, list);
  return [...list].sort((a,b)=>{
    const va = a[column], vb = b[column];
    if (type === 'date'){
      const da = parseDateLoose(va), db = parseDateLoose(vb);
      return f * ((da?.getTime() || 0) - (db?.getTime() || 0));
    }
    if (type === 'number'){
      return f * ((parseFloat(va) || 0) - (parseFloat(vb) || 0));
    }
    if (type === 'priority'){ return f * cmpPriority(va, vb); }
    if (type === 'status'){   return f * cmpStatus(va, vb); }
    if (type === 'id'){       return f * cmpId(va, vb); }
    return f * String(va ?? '').localeCompare(String(vb ?? ''), undefined, { numeric:true, sensitivity:'base' });
  });
}

function clearDesktopSortIndicators(container){
  container?.__thead?.querySelectorAll('th').forEach(th=>{
    th.removeAttribute('data-sort');
    th.setAttribute('aria-sort','none');
  });
}
function syncDesktopSortIndicators(container, column, direction){
  container?.__thead?.querySelectorAll('th').forEach(th=>{
    const col = th.getAttribute('data-col');
    if(col===column){
      th.setAttribute('data-sort', direction);
      th.setAttribute('aria-sort', direction==='asc'?'ascending':'descending');
    }else{
      th.removeAttribute('data-sort');
      th.setAttribute('aria-sort','none');
    }
  });
}
function updateMobileSortDirectionButton(container){
  const btn = container?.__mobileSortDirectionBtn;
  if(!btn) return;
  const dir = container.__mobileSortDirection==='asc'?'asc':'desc';
  btn.dataset.direction = dir;
  btn.textContent = dir==='asc' ? 'Ascending' : 'Descending';
  btn.setAttribute('aria-label', `Toggle sort direction (currently ${btn.textContent.toLowerCase()})`);
}
function updateMobileSortSummary(container){
  const wrap = container?.__mobileSortWrap;
  const summary = container?.__mobileSortSummary;
  if(!wrap || !summary) return;
  const select = container?.__mobileSortSelect;
  const current = container?.__currentSort;
  const hasSort = !!(current?.column);
  wrap.dataset.hasSort = hasSort ? 'true' : 'false';

  if(hasSort && select){
    const selected = select.options[select.selectedIndex];
    const label = selected ? selected.textContent.trim() : current.column;
    const dirLabel = container.__mobileSortDirection === 'asc' ? 'Ascending' : 'Descending';
    summary.textContent = `${label} · ${dirLabel}`;
  }else{
    summary.textContent = 'Default order';
  }
}
function setMobileSortOpen(container, open){
  const wrap = container?.__mobileSortWrap;
  const controls = container?.__mobileSortControls;
  const toggle = container?.__mobileSortToggle;
  if(!wrap || !controls || !toggle) return;
  const next = !!open;
  container.__mobileSortOpen = next;
  wrap.dataset.open = next ? 'true' : 'false';
  toggle.setAttribute('aria-expanded', next ? 'true' : 'false');
  controls.hidden = !next;
}
function setMobileSortVisibility(container, show){
  const wrap = container?.__mobileSortWrap;
  if(!wrap) return;
  const visible = !!show;
  wrap.hidden = !visible;
  if(!visible){
    setMobileSortOpen(container, false);
  }
}
function setSortState(container, column, direction){
  if(!container) return;
  const dir = direction==='asc'?'asc':'desc';
  container.__currentSort = column ? { column, direction: dir } : null;
  container.__mobileSortDirection = dir;

  if(container.__mobileSortSelect){
    container.__mobileSortSelect.value = column || '';
    container.__mobileSortDirectionBtn.disabled = !column || !isMobileView() || !(container.__rows?.length);
  }
  if(column) syncDesktopSortIndicators(container, column, dir);
  else clearDesktopSortIndicators(container);

  updateMobileSortDirectionButton(container);
  updateMobileSortSummary(container);
}

  function handleMobileSort(container){
  if(!container) return;
  const select = container.__mobileSortSelect;
  const tbodyEl = container.__tbody;
  const headers = container.__headers;
  if(!select || !tbodyEl || !headers) return;

  const column = select.value;
  const base = container.__rawRows ? container.__rawRows.slice() : [];

  if(!column){
    container.__rows = base.slice();
    setSortState(container, null, 'desc');
    renderRowsScoped(tbodyEl, headers, base, container);
    return;
  }

  const dir = container.__mobileSortDirection || 'desc';
  const sorted = applySort(base, column, dir);
  container.__rows = sorted.slice();
  setSortState(container, column, dir);
  renderRowsScoped(tbodyEl, headers, sorted, container);
}

function toggleMobileSortDirection(container){
  if(!container) return;
  const select = container.__mobileSortSelect;
  const tbodyEl = container.__tbody;
  const headers = container.__headers;
  if(!select || !select.value || !tbodyEl || !headers) return;

  const next = (container.__mobileSortDirection === 'asc') ? 'desc' : 'asc';
  const base = (container.__rows && container.__rows.length)
    ? container.__rows
    : (container.__rawRows || []);

  const sorted = applySort(base, select.value, next);
  container.__rows = sorted.slice();
  setSortState(container, select.value, next);
  renderRowsScoped(tbodyEl, headers, sorted, container);
}

// small helper so we can reuse category chip markup
  // === Freeze rule: red age + "Planned Winter Project" category ===
function hasWinterPlanTag(row){
  if(!row) return false;
  const pattern=/\b(planned\s*winter\s*project|winter\s*plan)\b/i;
  const fields=[
    row['Categories'],
    row['Tags'],
    row['Tag'],
    row['Title'],
  ];
  return fields.some(value=>pattern.test(String(value||'')));
}

function isWinterPlanned(row){
  if (!row) return false;
  const bucket = row.__ageBucket || ageBucket(row.__ageMs);
  return hasWinterPlanTag(row) && (bucket === 'old' || bucket === 'ancient'); // only “red” ages
}

function buildCategoryChips(value){
  const seen=new Set();
  return String(value||'')
    .split(/[,;]+/)
    .map(c=>c.trim()).filter(Boolean)
    .map(cat=>{
      const slug=slugify(cat);
      if(seen.has(slug)) return '';
      seen.add(slug);
      const { className, style } = chipStyle(cat, slug);
      const styleAttr = style ? ` style="${style}"` : '';
      const classAttr = className ? ` ${className}` : '';
      return `<span class="chip-cat${classAttr}"${styleAttr}>${esc(cat)}</span>`;
    }).filter(Boolean).join('');
}

// Filters
const $searchInput = document.getElementById('globalSearch');
const $statusFilter = document.getElementById('statusFilter');
const $priorityFilter = document.getElementById('priorityFilter');
const $activeFilterChips = document.getElementById('activeFilterChips');
  let PREFERRED_ACTIVE_DASH = null;

function getActiveDashId(){
  // Prefer the active TABLE panel, fall back to any .dash, then dash-all
  return document.querySelector('.dash-table[data-active="true"]:not([hidden])')?.id
      || document.querySelector('.dash[data-active="true"]:not([hidden])')?.id
      || 'dash-all';
}

function humanizeFilterValue(value){
  return String(value || '')
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function updateActiveFilterChips(filters){
  if(!$activeFilterChips) return;

  const chips=[];

  if(filters.status){
    const label=humanizeFilterValue(filters.status);
    const text=filters.excludeStatus?`Status ≠ ${label}`:`Status: ${label}`;
    const aria=filters.excludeStatus?`Clear status filter (not ${label})`:`Clear status filter: ${label}`;
   chips.push({
  key:'status',
  text,
  aria,
  onRemove:()=>{
    if($statusFilter){
      $statusFilter.value='';
      $statusFilter.dispatchEvent(new Event('change',{bubbles:true}));
    }
  }
});
  }

  if(filters.priority){
    const label=humanizeFilterValue(filters.priority);
    const text=`Priority: ${label}`;
    const aria=`Clear priority filter: ${label}`;
    chips.push({
      key:'priority',
      text,
      aria,
      onRemove:()=>{
        if($priorityFilter){
          $priorityFilter.value='';
          $priorityFilter.dispatchEvent(new Event('change',{bubbles:true}));
        }
      }
    });
  }

  if(filters.search){
    const text=`Search: ${filters.search}`;
    const aria=`Clear search filter: ${filters.search}`;
    chips.push({
  key:'search',
  text,
  aria,
  onRemove:()=>{
    if($searchInput){
      $searchInput.value='';
      // fire input so filtering runs immediately
      $searchInput.dispatchEvent(new Event('input',{bubbles:true}));
      $searchInput.dispatchEvent(new Event('change', {bubbles:true}));
    }
  }
});
  }

  if(!chips.length){
    $activeFilterChips.innerHTML='';
    $activeFilterChips.setAttribute('hidden','');
    return;
  }

  const frag=document.createDocumentFragment();
  chips.forEach(chip=>{
    const btn=document.createElement('button');
    btn.type='button';
    btn.className='filter-chip';
    btn.dataset.filter=chip.key;
    btn.setAttribute('aria-label', chip.aria);
    btn.title=chip.aria;

    const label=document.createElement('span');
    label.className='filter-chip__label';
    label.textContent=chip.text;

    const icon=document.createElement('span');
    icon.className='filter-chip__icon';
    icon.setAttribute('aria-hidden','true');
    icon.textContent='×';

    btn.append(label, icon);
    btn.addEventListener('click', chip.onRemove);
    frag.appendChild(btn);
  });

  $activeFilterChips.innerHTML='';
  $activeFilterChips.removeAttribute('hidden');
  $activeFilterChips.appendChild(frag);
}

function getFilters(){
  const rawStatus = ($statusFilter?.value || '').trim().toLowerCase();
  let status = '';
  let excludeStatus = false;

  // use the real input you have in the HTML
  const searchTerm = ($searchInput?.value || '').trim();

  if(rawStatus){
    const negMatch = rawStatus.match(/^(?:not[:\s]+|!)(.+)$/);
    if(negMatch){
      status = negMatch[1].trim();
      excludeStatus = true;
    }else{
      status = rawStatus;
    }
  }

  status = status ? statusClass(status) : '';
  if(!status){
    excludeStatus = false;
  }

  return {
    status,
    excludeStatus,
    priority: normalizePriority($priorityFilter?.value || ''),
    searchTerm
  };
}

const SEARCH_KEYS = ['ID','Title','Status','Priority','Assigned to','Created by','Created on','Completed on','Last updated','Location','Asset','Categories','Age'];

function buildHaystack(row){
  if(!row) return '';
  return SEARCH_KEYS
    .map(key => String(row[key] ?? ''))
    .join(' ')
    .toLowerCase();
}

function applyFilters(rows){
  const filters = getFilters();

  // Keep the chips UI updated (mapped to `search`)
  updateChipsFromFilters(filters);

  const { status, excludeStatus, priority, searchTerm } = filters;
  const tokens = searchTerm ? searchTerm.toLowerCase().split(/\s+/).filter(Boolean) : [];

  return rows.filter(r => {
    const rowStatus = statusClass(r['Status']);
    const okStatus = !status ? true : (excludeStatus ? rowStatus !== status : rowStatus === status);
    const okPrio   = !priority || normalizePriority(r['Priority']) === priority;

    let okSearch = true;
    if(tokens.length){
      const hay = r.__haystack || '';
      okSearch = tokens.every(t => hay.includes(t));
    }

    return okStatus && okPrio && okSearch;
  });
}
  function updatePriorityOnlyChip(container){
  if(!$activeFilterChips || !container) return;
  const existing = $activeFilterChips.querySelector('[data-filter="priority-tag"]');

  if(!container.__priorityOnly){
    existing?.remove();
    if(!$activeFilterChips.querySelector('.filter-chip')) $activeFilterChips.setAttribute('hidden','');
    return;
  }

  $activeFilterChips.removeAttribute('hidden');
  const btn = existing || document.createElement('button');
  btn.type='button';
  btn.className='filter-chip';
  btn.dataset.filter='priority-tag';
  btn.setAttribute('aria-label','Clear “Priority” category filter');
  btn.title='Clear “Priority” category filter';
  btn.innerHTML = `<span class="filter-chip__label">Category: Priority</span><span class="filter-chip__icon" aria-hidden="true">×</span>`;
  btn.onclick = ()=>{
    container.__priorityOnly = false;

    let working = (container.__rawRows || []).slice();

    // keep “Oldest only” behavior if it’s on
if (container.__focusOldest){
  const pick = working
    .filter(r => !isWinterPlanned(r))     // ← add this
    .reduce((acc, r) => {
      const ms = r.__ageMs ?? ageMs(r);
      if (ms == null) return acc;
      return (!acc || ms > (acc.__ageMs ?? ageMs(acc))) ? r : acc;
    }, null);
  working = pick ? [pick] : [];
}

    const s = container.__currentSort;
    if (s && s.column) working = applySort(working, s.column, s.direction);

    container.__rows = working.slice();
renderRowsSmart(container.__tbody, container.__headers, working, container);

    // un-press the KPI card if present
    container.__prioKpiCard?.setAttribute('aria-pressed','false');

    updatePriorityOnlyChip(container);
    updateTheadHeight();
  };

  if(!existing) $activeFilterChips.appendChild(btn);
}

function updateOldestOnlyChip(container){
  if(!$activeFilterChips || !container) return;
  const existing = $activeFilterChips.querySelector('[data-filter="oldest-only"]');

  if(!container.__focusOldest){
    existing?.remove();
    if(!$activeFilterChips.querySelector('.filter-chip')) $activeFilterChips.setAttribute('hidden','');
    return;
  }

  $activeFilterChips.removeAttribute('hidden');
  const btn = existing || document.createElement('button');
  btn.type='button';
  btn.className='filter-chip';
  btn.dataset.filter='oldest-only';
  btn.setAttribute('aria-label','Clear oldest-only filter');
  btn.title='Clear oldest-only filter';
  btn.innerHTML = `<span class="filter-chip__label">Oldest only</span><span class="filter-chip__icon" aria-hidden="true">×</span>`;
  btn.onclick = ()=>{
    container.__focusOldest = false;

    let working = (container.__rawRows || []).slice();
    const s = container.__currentSort;
    if (s && s.column) working = applySort(working, s.column, s.direction);

    container.__rows = working.slice();
renderRowsSmart(container.__tbody, container.__headers, working, container);

    // only update the KPI in this site's panel
    const site = container.dataset.site || container.id.replace(/^dash-/, '');
    const kpiCardBtn = document.querySelector(`.dash-kpis[data-site="${site}"] .kpi-clickable`);
    kpiCardBtn?.setAttribute('aria-pressed','false');

    updateOldestOnlyChip(container);
    updateTheadHeight();
  };
  
  // ⬇️ these two lines were missing
  if(!existing) $activeFilterChips.appendChild(btn);
}
  
// Rendering
function renderDashboard(container, headers, rows){
  // keep previous sort direction if we re-render this dash
  const prevSort = container.__currentSort;
  const prevDir  = container.__mobileSortDirection || (prevSort?.direction ?? 'desc');

  container.innerHTML='';

  const siteKey = container.dataset.site || container.id.replace(/^dash-/, '');
  const kpiContainer = siteKey ? document.querySelector(`.dash-kpis[data-site="${siteKey}"]`) : null;

  // KPIs
  const kpiWrap=document.createElement('div'); kpiWrap.className='kpis';
  const open =rows.filter(r=>/^open$/i.test(r.Status)).length;
  const prog =rows.filter(r=>/^in\s*progress$/i.test(r.Status)).length;
  const hold =rows.filter(r=>/^on\s*hold$/i.test(r.Status)).length;
  const done =rows.filter(r=>/^done$/i.test(r.Status)).length;
// Counts (clickable toggles)
kpiWrap.appendChild(makeStatusKpi('Open',        'open',        open, container));
kpiWrap.appendChild(makeStatusKpi('In Progress', 'in-progress', prog, container));
kpiWrap.appendChild(makeStatusKpi('On Hold',     'on-hold',     hold, container));
kpiWrap.appendChild(makeStatusKpi('Done',        'done',        done, container));

// --- Oldest Age – clickable filter
const oldestEntry = rows
  .filter(r => !isWinterPlanned(r)) // ignore frozen
  .reduce((acc, r) => {
    const ms = r.__ageMs ?? ageMs(r);
    if (ms == null) return acc;
    return (!acc || ms > acc.ms) ? { row:r, ms } : acc;
  }, null);

if (oldestEntry) {
  const oldestCard = kpiCard('Oldest Age', fmtAge(oldestEntry.ms));
  oldestCard.classList.add('kpi-clickable');
  oldestCard.setAttribute('role','button');
  oldestCard.setAttribute('tabindex','0');
  oldestCard.setAttribute('aria-pressed', container.__focusOldest ? 'true' : 'false');
  oldestCard.setAttribute('title','Show only the oldest work order (toggle)');
  oldestCard.setAttribute('aria-label','Toggle oldest work order filter');

const applyFocusOldest = () => {
  container.__focusOldest = !container.__focusOldest;
  oldestCard.setAttribute('aria-pressed', container.__focusOldest ? 'true' : 'false');

  // start from this site's filtered rows
  let working = (container.__rawRows || []).slice();

  // keep Priority toggle if it’s on
  if (container.__priorityOnly) {
    working = working.filter(hasPriorityCategory);
  }

if (container.__focusOldest) {
  const pick = working
    .filter(r => !isWinterPlanned(r))
    .reduce((acc, r) => {
      const ms = r.__ageMs ?? ageMs(r);
      if (ms == null) return acc;
      return (!acc || ms > (acc.__ageMs ?? ageMs(acc))) ? r : acc;
    }, null);
  working = pick ? [pick] : [];
}

  // honor current sort
  const s = container.__currentSort;
  if (s && s.column) working = applySort(working, s.column, s.direction);

  container.__rows = working.slice();
renderRowsSmart(container.__tbody, container.__headers, working, container);
  updateOldestOnlyChip(container);
  updateTheadHeight();
  pulse(container.__tableWrap);   // 👈 add this line
};

  oldestCard.addEventListener('click', applyFocusOldest);
  oldestCard.addEventListener('keydown', e => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); applyFocusOldest(); }
  });

  kpiWrap.appendChild(oldestCard);
}

// --- Priority WOs – always show
const prioTagCount = rows.filter(hasPriorityCategory).length;
const prioCard = kpiCard('Priority WOs', prioTagCount);
prioCard.classList.add('kpi-clickable');
prioCard.setAttribute('role','button');
prioCard.setAttribute('tabindex','0');
prioCard.setAttribute('aria-pressed', container.__priorityOnly ? 'true' : 'false');
prioCard.setAttribute('title','Show only rows that include the “Priority” category (toggle)');
prioCard.setAttribute('aria-label','Toggle Priority category filter');
container.__prioKpiCard = prioCard;

const togglePrio = () => {
  container.__priorityOnly = !container.__priorityOnly;
  prioCard.setAttribute('aria-pressed', container.__priorityOnly ? 'true' : 'false');

  let working = (container.__rawRows || []).slice();
  if (container.__priorityOnly) {
    working = working.filter(hasPriorityCategory);
  }
if (container.__focusOldest) {
  const pick = working
    .filter(r => !isWinterPlanned(r))     // ← ignore frozen PWPs
    .reduce((acc, r) => {
      const ms = r.__ageMs ?? ageMs(r);
      if (ms == null) return acc;
      return (!acc || ms > (acc.__ageMs ?? ageMs(acc))) ? r : acc;
    }, null);
  working = pick ? [pick] : [];
}

  const s = container.__currentSort;
  if (s && s.column) working = applySort(working, s.column, s.direction);

  container.__rows = working.slice();
renderRowsSmart(container.__tbody, container.__headers, working, container);
  updatePriorityOnlyChip(container);
  updateTheadHeight();
  pulse(container.__tableWrap);   // 👈 add this line
};

prioCard.addEventListener('click', togglePrio);
prioCard.addEventListener('keydown', e => {
  if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); togglePrio(); }
});

kpiWrap.appendChild(prioCard);

  if(kpiContainer){ kpiContainer.innerHTML=''; kpiContainer.appendChild(kpiWrap); }

// --- shell: table + mobile containers (both exist; CSS decides visibility) ---
const tableWrap = document.createElement('div');
tableWrap.className = 'table-scroll';

const table  = document.createElement('table');
const thead  = document.createElement('thead');
const tbody  = document.createElement('tbody');

applyColumnWidths(table, headers);
table.append(thead, tbody);

tableWrap.append(table);

const mobileSortWrap = document.createElement('div');
mobileSortWrap.className = 'mobile-sort';

const selectId = `${container.id || siteKey || 'dash'}-mobile-sort`;
const controlsId = `${selectId}-controls`;

const mobileSortToggle = document.createElement('button');
mobileSortToggle.type = 'button';
mobileSortToggle.className = 'mobile-sort__toggle';
mobileSortToggle.setAttribute('aria-expanded','false');

const toggleLabel = document.createElement('span');
toggleLabel.className = 'mobile-sort__toggle-label';
toggleLabel.textContent = 'Sort options';

const toggleSummary = document.createElement('span');
toggleSummary.className = 'mobile-sort__summary';
toggleSummary.textContent = 'Default order';

mobileSortToggle.append(toggleLabel, toggleSummary);

const mobileSortControls = document.createElement('div');
mobileSortControls.className = 'mobile-sort__controls';
mobileSortControls.id = controlsId;
mobileSortControls.hidden = true;
mobileSortToggle.setAttribute('aria-controls', controlsId);

const mobileSortLabel = document.createElement('label');
mobileSortLabel.className = 'mobile-sort__label';
mobileSortLabel.setAttribute('for', selectId);
mobileSortLabel.textContent = 'Sort by';

const mobileSortSelect = document.createElement('select');
mobileSortSelect.id = selectId;
mobileSortSelect.className = 'mobile-sort__select';

const defOpt = document.createElement('option');
defOpt.value = '';
defOpt.textContent = 'Default order';
mobileSortSelect.appendChild(defOpt);
headers.forEach(h => {
  const o = document.createElement('option');
  o.value = h; o.textContent = h;
  mobileSortSelect.appendChild(o);
});

const mobileSortDirBtn = document.createElement('button');
mobileSortDirBtn.type = 'button';
mobileSortDirBtn.className = 'mobile-sort__direction';

mobileSortControls.append(mobileSortLabel, mobileSortSelect, mobileSortDirBtn);
mobileSortWrap.append(mobileSortToggle, mobileSortControls);

const mobileCards = document.createElement('div');
mobileCards.className = 'mobile-cards';

const emptyState = document.createElement('div');
emptyState.className = 'dash-empty';
emptyState.textContent = 'No work orders match the current filters.';
emptyState.hidden = true;

container.append(tableWrap, mobileSortWrap, mobileCards, emptyState);

// cache refs on the dashboard section element
container.__headers = headers.slice();
container.__tableWrap = tableWrap;
container.__thead = thead;
container.__tbody = tbody;
container.__mobileCards = mobileCards;
container.__mobileSortWrap = mobileSortWrap;
container.__mobileSortToggle = mobileSortToggle;
container.__mobileSortControls = mobileSortControls;
container.__mobileSortSelect = mobileSortSelect;
container.__mobileSortDirectionBtn = mobileSortDirBtn;
container.__mobileSortSummary = toggleSummary;
container.__emptyState = emptyState;

setMobileSortOpen(container, false);
updateMobileSortSummary(container);
updateMobileSortDirectionButton(container);

  // table header + sorting (desktop)
  thead.innerHTML = `<tr>${headers.map(h=>`<th scope="col" data-col="${esc(h)}" tabindex="0"><span>${esc(h)}</span><span class="sort-arrow" aria-hidden="true"></span></th>`).join('')}</tr>`;
  thead.querySelectorAll('th').forEach(th=>{
    th.setAttribute('aria-sort','none');
    th.addEventListener('click', ()=> sortScoped(th, container));
    th.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); sortScoped(th, container); } });
  });

  // mobile sort UI
  mobileSortSelect.addEventListener('change', ()=> handleMobileSort(container));
  mobileSortDirBtn.addEventListener('click', ()=>{ if(!mobileSortDirBtn.disabled) toggleMobileSortDirection(container); });
  mobileSortToggle.addEventListener('click', ()=>{
    const next = !container.__mobileSortOpen;
    setMobileSortOpen(container, next);
    if(next){
      queueMicrotask(()=> mobileSortSelect.focus());
    }
  });

  // initial data & sort
  const baseRows = rows.slice();
  container.__rawRows = baseRows.slice();
  let working = baseRows;
  if(prevSort && headers.includes(prevSort.column)){
    working = applySort(baseRows, prevSort.column, prevDir);
  }
// If "Oldest Age" toggle is active, reduce to just that one row (ignore frozen PWP)
if (container.__focusOldest) {
  const pick = working
    .filter(r => !isWinterPlanned(r))
    .reduce((acc, r) => {
      const ms = r.__ageMs ?? ageMs(r);
      if (ms == null) return acc;
      return (!acc || ms > (acc.__ageMs ?? ageMs(acc))) ? r : acc;
    }, null);
  working = pick ? [pick] : [];
}

  // apply the priority-tag filter when enabled
  if (container.__priorityOnly) {
    working = working.filter(hasPriorityCategory);
  }
  container.__rows = working.slice();
  setSortState(container, prevSort?.column || null, prevDir);

  // draw once for current viewport, then measure sticky
renderRowsSmart(tbody, headers, working, container);
  updateOldestOnlyChip(container);   // <-- add this
  updatePriorityOnlyChip(container);
  updateTheadHeight();
}

function sortScoped(th, container){
  if(!container) return;
  const tbodyEl = container.__tbody;
  const headers = container.__headers;
  if(!tbodyEl || !headers) return;

  const col = th.getAttribute('data-col');
  if(!col) return;

  // toggle direction (if same col -> flip; else default to asc)
  const current = container.__currentSort;
  const nextDir =
    current && current.column === col && current.direction === 'asc'
      ? 'desc'
      : 'asc';

  const base = (container.__rows && container.__rows.length)
    ? container.__rows
    : (container.__rawRows || []);

  const sorted = applySort(base, col, nextDir);
  container.__rows = sorted.slice();

  setSortState(container, col, nextDir);               // updates desktop + mobile UI
  renderRowsScoped(tbodyEl, headers, sorted, container);
  setSortState(container, col, nextDir);
}
  
function updateTheadHeight(){
  const activeDash =
    document.querySelector('.dash-table[data-active="true"]:not([hidden])') ||
    Array.from(document.querySelectorAll('.dash-table'))
      .find(el => el.offsetParent !== null && !el.hidden);

  const thead = activeDash?.querySelector('thead');
  let h = thead ? thead.getBoundingClientRect().height : 40;
  h = Math.max(28, Math.min(64, h)); // clamp
  document.documentElement.style.setProperty('--thead-height', `${h}px`);
}

// Run on load
document.addEventListener('DOMContentLoaded', updateTheadHeight);

// Run on resize
window.addEventListener('resize', updateTheadHeight);

function ingestToDashboards(headers, rows){
  // Always reset cached data so future loads start fresh
  window.__ALS_GROUPS = undefined;
  window.__ALS_HEADERS = undefined;
  window.__ALS_GROUP_MAP = undefined;

  // 1) Remember which dashboard is currently active
  const prevActiveId =
    document.querySelector('.dash[data-active="true"]:not([hidden])')?.id || null;
  const expected=['ID','Title','Status','Priority','Assigned to','Created by','Created on','Completed on','Last updated','Location','Asset','Categories'];
  const present = expected.filter(h => headers.includes(h));
  const baseHeaders = present.length ? present : expected;

  updateExportButtonsState();

  // normalize + derive age
  const normalized = rows.map(r => {
    const o={}; expected.forEach(h => { o[h] = r[h] ?? ''; });
      // shorten people/team fields
  o['Assigned to'] = shortenName(o['Assigned to']);
  o['Created by']  = shortenName(o['Created by']);

    const ms = ageMs(o);
    o.__ageMs      = ms;                // raw milliseconds
    o.Age          = fmtAge(ms);        // human label like "12d 3h"
    o.__ageBucket  = ageBucket(ms);     // fresh | stale | old | ancient
    o.__haystack   = buildHaystack(o);  // cached lower-case search text
    return o;
  });

  const filtered = applyFilters(normalized);

const displayHeaders = (() => {
  const out = baseHeaders.slice();

  // 1) Created on → Last updated → Completed on
  const trio = ['Created on', 'Last updated', 'Completed on'];
  const presentTrio = trio.filter(h => out.includes(h));
  if (presentTrio.length) {
    const firstIdx = Math.min(...presentTrio.map(h => out.indexOf(h)));
    trio.forEach(h => {
      const i = out.indexOf(h);
      if (i > -1) out.splice(i, 1);
    });
    out.splice(firstIdx, 0, ...presentTrio);
  }

  // 2) Put Age immediately AFTER "Completed on"
  const afterIdx = out.indexOf('Completed on');
  const targetIdx = afterIdx >= 0 ? afterIdx + 1 : out.length;

  if (!out.includes('Age')) {
    out.splice(targetIdx, 0, 'Age');
  } else {
    const ageIdx = out.indexOf('Age');
    if (ageIdx !== targetIdx && ageIdx !== -1) {
      out.splice(ageIdx, 1);
      out.splice(Math.min(targetIdx, out.length), 0, 'Age');
    }
  }
  return out;
})();

  const groups={
    all  : filtered,
    ek   : filtered.filter(r=>toSiteKey(r.Location)==='ek'),
    mm   : filtered.filter(r=>toSiteKey(r.Location)==='mm'),
    keith: filtered.filter(r=>toSiteKey(r.Location)==='keith'),
    winter: filtered.filter(hasWinterPlanTag),
    by   : filtered.filter(r=>toSiteKey(r.Location)==='by'),
  };

  const dashEntries = [
    ['dash-all','all'],
    ['dash-ek','ek'],
    ['dash-mm','mm'],
    ['dash-keith','keith'],
    ['dash-by','by'],
    ['dash-winter','winter']
  ];

  window.__ALS_GROUPS = groups;
  window.__ALS_HEADERS = displayHeaders.slice();
  window.__ALS_GROUP_MAP = dashEntries.reduce((acc, [id, key]) => {
    acc[id] = key;
    return acc;
  }, {});

  const currentActiveId = getActiveDashId();

  dashEntries.forEach(([id, key]) => {
    const el = document.getElementById(id);
    if (!el){ console.warn?.(`Skipping dashboard "${id}" – element not found.`); return; }
    el.__needsRender = true;

    if (id === currentActiveId){
      renderDashboard(el, displayHeaders, groups[key] || []);
      el.__needsRender = false;
    }
  });

// restore preferred/previous site
const targetId =
  PREFERRED_ACTIVE_DASH
  || prevActiveId
  || (document.getElementById('dash-all') ? 'dash-all' : document.querySelector('.dash')?.id);

PREFERRED_ACTIVE_DASH = null;
if (targetId) setActiveDash(targetId);
syncLayoutToggle();
refreshPlanWithWorkOrders();
} // closes function ingestToDashboards


// Tabs
const tabs = Array.from(document.querySelectorAll('.nav .tab'));
const WINTER_TAB_ID = 'dash-winter';
let lastNonWinterDashId = 'dash-all';

function handleTabClick(btn){
  const targetId = btn?.getAttribute('aria-controls');
  if(!targetId) return;
  const activeId = getActiveDashId();

  if(targetId === WINTER_TAB_ID && activeId === WINTER_TAB_ID){
    const fallbackId = lastNonWinterDashId && lastNonWinterDashId !== WINTER_TAB_ID
      ? lastNonWinterDashId
      : 'dash-all';
    setActiveDash(fallbackId);
    return;
  }

  setActiveDash(targetId);
}

tabs.forEach(btn => btn.addEventListener('click', ()=> handleTabClick(btn)));
function setActiveDash(id){
  const active = document.getElementById(id);
  if(!active) return;  // guard

  const site = active.dataset.site || active.id.replace(/^dash-/, '');
  if(id !== WINTER_TAB_ID){
    lastNonWinterDashId = id;
  }
  SeasonalTheme.apply(site);
  document.querySelectorAll('.dash').forEach(sec => {
    const isMatch = sec.dataset.site === site;
    sec.setAttribute('data-active', String(isMatch));
    sec.hidden = !isMatch;
  });

  document.querySelectorAll('.dash-kpis').forEach(panel => {
    const isMatch = panel.dataset.site === site;
    panel.hidden = !isMatch;
  });

  // sync tabs safely
  document.querySelectorAll('.nav .tab').forEach(t => {
    const controls = t.getAttribute('aria-controls');
    t.setAttribute('aria-selected', String(controls === id));
  });

  if (active.__needsRender && window.__ALS_HEADERS && window.__ALS_GROUPS){
    const map = window.__ALS_GROUP_MAP || {};
    const key = map[id] || site;
    const rows = window.__ALS_GROUPS[key] || [];
    renderDashboard(active, window.__ALS_HEADERS, rows);
    active.__needsRender = false;
  }

  updateStickyControlsOffset();
  updateTheadHeight();
  updateTableMaxHeight();   // 👈 ensures the new table scroller fits perfectly
}
  // run at startup
window.addEventListener('load', updateTableMaxHeight);

// keep it correct on resize and when fonts settle
window.addEventListener('resize', updateTableMaxHeight);
document.fonts?.ready?.then(()=>{ try { updateTableMaxHeight(); } catch{} });

  // --- collapsible sticky header ---
const $sticky = document.querySelector('.sticky-top');
const $collapseBtn = document.getElementById('hide-controls');
const $controlsPanel = document.querySelector('[data-controls-panel]') || document.getElementById('controls-panel');
const controlsTargetId = $collapseBtn?.dataset.controls;
const $controlsBar = controlsTargetId ? document.getElementById(controlsTargetId) : null;

function setCollapsed(isCollapsed){
  if(!$sticky || !$collapseBtn) return;
  $sticky.dataset.collapsed = isCollapsed ? 'true' : 'false';
  const label = isCollapsed ? 'Show controls' : 'Hide controls';
  const labelEl = $collapseBtn.querySelector('.label');
  if(labelEl){
    labelEl.textContent = label;
  }else{
    $collapseBtn.textContent = label;
  }
  $collapseBtn.setAttribute('aria-expanded', String(!isCollapsed));
  $collapseBtn.setAttribute('aria-pressed', isCollapsed ? 'true' : 'false');
  $collapseBtn.setAttribute('aria-label', label);
  $collapseBtn.title = label;

  const hiddenTargets = $sticky.querySelectorAll('.sticky-content, .controls');
  hiddenTargets.forEach(el => {
    if (isCollapsed){
      el.setAttribute('aria-hidden', 'true');
    } else {
      el.removeAttribute('aria-hidden');
    }
  });

  if($controlsPanel){
    $controlsPanel.style.display = isCollapsed ? 'none' : '';
  }
  if($controlsBar && $controlsBar !== $controlsPanel){
    $controlsBar.style.display = isCollapsed ? 'none' : '';
  }

  // keep layout/overlays correct
  updateStickyControlsOffset();
  updateTheadHeight();
  updateTableMaxHeight();   // 👈 add this line
}

// restore saved state (default: expanded)
const saved = localStorage.getItem('alsStickyCollapsed');
setCollapsed(saved === '1');

// optional: start collapsed on phones — uncomment to enable
// if (isMobileView() && saved === null) setCollapsed(true);

$collapseBtn?.addEventListener('click', ()=>{
  const now = $sticky?.dataset.collapsed === 'true';
  setCollapsed(!now);
  localStorage.setItem('alsStickyCollapsed', !now ? '1' : '0');
});

// Refresh index + dashboards
const refreshBtn = document.getElementById('refreshBtn');
refreshBtn?.addEventListener('click', async ()=>{
  showLoading('Refreshing…');
  try{
    await loadLatestOrChosenWeek(true); // busts index + week now
  }catch(e){
    console.error(e);
    alert('Could not refresh. ' + (e?.message || ''));
  }finally{
    hideLoading();
  }
});

  function wireExternalWeekArrows(){
  const prevs = document.querySelectorAll('#weekPrev,[data-week-nav="prev"]');
  const nexts = document.querySelectorAll('#weekNext,[data-week-nav="next"]');

  const wire = (btn, handler) => {
    if (btn.dataset.wired === '1') return;
    btn.dataset.wired = '1';
    btn.type = btn.type || 'button';
    btn.addEventListener('click', handler);
  };

  prevs.forEach(btn => wire(btn, () => gotoWeekByOffset(+1)));
  nexts.forEach(btn => wire(btn, () => gotoWeekByOffset(-1)));
  refreshWeekArrowDisabled();
}

// Theme + seasonal overlays
const themeBtn=document.getElementById('dark-toggle');
const layoutToggleBtn=document.getElementById('layout-toggle');
const LAYOUT_MODE_STORAGE_KEY='alsLayoutMode';
let __wasMobile;

function currentForcedLayout(){
  if(document.body.classList.contains('force-mobile')) return 'mobile';
  if(document.body.classList.contains('force-desktop')) return 'desktop';
  return 'auto';
}

function syncLayoutToggle(){
  if(!layoutToggleBtn) return;
  const mode=currentForcedLayout();
  const labelEl=layoutToggleBtn.querySelector('.switch-label')||layoutToggleBtn.querySelector('.label');
  if(labelEl){
    if(mode==='mobile') labelEl.textContent='Mobile view';
    else if(mode==='desktop') labelEl.textContent='Desktop view';
    else labelEl.textContent=isMobileView()?'Auto · Mobile':'Auto · Desktop';
  }
  const nextAction=mode==='mobile'?'Switch to desktop view':mode==='desktop'?'Return to automatic view':'Switch to mobile view';
  layoutToggleBtn.setAttribute('aria-checked',mode==='mobile'?'true':'false');
  layoutToggleBtn.setAttribute('aria-label',nextAction);
  layoutToggleBtn.title=nextAction;
}

function applyLayoutMode(mode,{persist=true}={}){
  const desired=mode==='mobile'?'mobile':mode==='desktop'?'desktop':'auto';
  if(desired==='mobile'){
    document.body.classList.add('force-mobile');
    document.body.classList.remove('force-desktop');
    if(persist) localStorage.setItem(LAYOUT_MODE_STORAGE_KEY,'mobile');
  }else if(desired==='desktop'){
    document.body.classList.add('force-desktop');
    document.body.classList.remove('force-mobile');
    if(persist) localStorage.setItem(LAYOUT_MODE_STORAGE_KEY,'desktop');
  }else{
    document.body.classList.remove('force-mobile');
    document.body.classList.remove('force-desktop');
    if(persist) localStorage.removeItem(LAYOUT_MODE_STORAGE_KEY);
  }
  syncLayoutToggle();
  __wasMobile=isMobileView();
  if(typeof ingestToDashboards==='function' && LAST_HEADERS && ALL_ROWS){
    ingestToDashboards(LAST_HEADERS,ALL_ROWS);
  }
  if(typeof updateStickyControlsOffset==='function') updateStickyControlsOffset();
  if(typeof updateTheadHeight==='function') updateTheadHeight();
  if(typeof updateTableMaxHeight==='function') updateTableMaxHeight();
}

function cycleLayoutMode(){
  const mode=currentForcedLayout();
  const next=mode==='mobile'?'desktop':mode==='desktop'?'auto':'mobile';
  applyLayoutMode(next);
}

function restoreStoredLayoutMode(){
  const stored=localStorage.getItem(LAYOUT_MODE_STORAGE_KEY);
  if(stored==='mobile' || stored==='desktop'){
    applyLayoutMode(stored,{persist:false});
  }else{
    syncLayoutToggle();
  }
}

layoutToggleBtn?.addEventListener('click',cycleLayoutMode);
const metaColorScheme=document.querySelector('meta[name="color-scheme"]');
const ThemeController=(()=>{
  const STORAGE_KEY='alsDesiredTheme';
  const WINTER_LIGHTS_KEY='alsWinterLights';
  const motionQuery=window.matchMedia?window.matchMedia('(prefers-reduced-motion: reduce)'):null;
  const storedTheme=localStorage.getItem(STORAGE_KEY);
  let desiredTheme=storedTheme==='dark'?'dark':storedTheme==='light'?'light':null;
  if(!desiredTheme){
    const media=window.matchMedia?window.matchMedia('(prefers-color-scheme: dark)'):null;
    desiredTheme=media?.matches?'dark':'light';
  }
  if(!desiredTheme){
    desiredTheme='light';
  }
  let winterLock=false;
  let winterLights=localStorage.getItem(WINTER_LIGHTS_KEY)==='1';

  const updateThemeButtonLabel=(text)=>{
    if(!themeBtn) return;
    const labelEl=themeBtn.querySelector('.switch-label') || themeBtn.querySelector('.label');
    if(labelEl){
      labelEl.textContent=text;
    }else{
      themeBtn.textContent=text;
    }
  };

  function isWinterPlanActive(){
    return winterLock;
  }

  function prefersReducedMotion(){
    return motionQuery?.matches ?? false;
  }

  function applyVisualTheme(theme){
    const normalized=theme==='dark'?'dark':'light';
    document.body.classList.toggle('dark', normalized==='dark');
    document.body.classList.toggle('light', normalized!=='dark');
    document.body.classList.toggle('theme-dark', normalized==='dark');
    document.documentElement.setAttribute('color-scheme', normalized);
    metaColorScheme?.setAttribute('content', normalized);
    applyChristmasLights();
  }

  function refreshButton(){
    if(!themeBtn) return;
    const preferDark=desiredTheme==='dark';
    if(isWinterPlanActive()){
      const activeLights=winterLights && !prefersReducedMotion();
      const offTitle='Enable light mode to turn on the Christmas lights.';
      const onTitle='Light mode is on. Click to turn off the Christmas lights.';
      updateThemeButtonLabel('Light');
      const title=activeLights?onTitle:offTitle;
      themeBtn.title=title;
      themeBtn.setAttribute('aria-label', title);
      themeBtn.setAttribute('aria-checked', activeLights?'true':'false');
    }else{
      updateThemeButtonLabel(preferDark?'Light':'Dark');
      const title=preferDark?'Currently dark. Click to switch to light mode.':'Currently light. Click to switch to dark mode.';
      themeBtn.title=title;
      themeBtn.setAttribute('aria-label', title);
      themeBtn.setAttribute('aria-checked', preferDark?'true':'false');
    }
    themeBtn.disabled=false;
    themeBtn.removeAttribute('aria-disabled');
  }

  function setTheme(theme,{force=false,skipStore=false}={}){
    const normalized=theme==='dark'?'dark':'light';
    if(!skipStore){
      desiredTheme=normalized;
      localStorage.setItem(STORAGE_KEY, normalized);
    }
    if(isWinterPlanActive() && !force){
      refreshButton();
      return;
    }
    applyVisualTheme(normalized);
    refreshButton();
  }

  function applyChristmasLights(){
    if(!window.ChristmasLights) return;
    const shouldGlow=winterLights && isWinterPlanActive() && !prefersReducedMotion();
    if(shouldGlow){
      window.ChristmasLights.enable();
    }else{
      window.ChristmasLights.disable();
    }
    window.ChristmasLights.refresh?.();
  }

  function setWinterLights(on,{skipStore=false}={}){
    winterLights=!!on;
    if(!skipStore){
      localStorage.setItem(WINTER_LIGHTS_KEY, winterLights?'1':'0');
    }
    applyChristmasLights();
    refreshButton();
  }

  function applyStoredTheme({force=false}={}){
    setTheme(desiredTheme,{force,skipStore:true});
  }

  function enforceWinterTheme(){
    setTheme('dark',{force:true,skipStore:true});
  }

  function toggle(){
    if(isWinterPlanActive()){
      setWinterLights(!winterLights);
    }else{
      const next=desiredTheme==='dark'?'light':'dark';
      setTheme(next);
    }
  }

  function setWinterLock(active){
    winterLock=!!active;
    refreshButton();
    applyChristmasLights();
  }

  function init(){
    applyVisualTheme(desiredTheme);
    applyChristmasLights();
    refreshButton();
    themeBtn?.addEventListener('click', ()=>{ toggle(); });
    if(motionQuery){
      const handler=()=>{
        if(isWinterPlanActive()){
          applyVisualTheme('dark');
        }else{
          applyVisualTheme(desiredTheme);
        }
      };
      if(motionQuery.addEventListener){
        motionQuery.addEventListener('change', handler);
      }else if(motionQuery.addListener){
        motionQuery.addListener(handler);
      }
    }
  }

  return {
    init,
    setTheme,
    toggle,
    applyStoredTheme,
    enforceWinterTheme,
    setWinterLock,
    isWinterPlanActive,
    prefersReducedMotion,
    applyChristmasLights,
    setWinterLights,
  };
})();

function isWinterPlanActive(){
  return ThemeController.isWinterPlanActive();
}

const SeasonalTheme=(()=>{
  function apply(site){
    const isWinter=site==='winter';
    if(isWinter){
      document.body.classList.add('winter');
    }
    ThemeController.setWinterLock(isWinter);

    if(isWinter){
      ThemeController.enforceWinterTheme();
      if(window.WinterOverlay){
        window.WinterOverlay.setDensity('medium');
        window.WinterOverlay.refresh?.();
      }
      ThemeController.applyChristmasLights();
    }else{
      const finishTeardown=()=>{
        document.body.classList.remove('winter');
        ThemeController.applyStoredTheme({ force:true });
        ThemeController.applyChristmasLights();
      };
      try{
        const teardown=window.WinterOverlay?.destroy?.();
        if(teardown && typeof teardown.then==='function'){
          teardown.then(finishTeardown).catch(finishTeardown);
        }else{
          finishTeardown();
        }
      }catch{
        finishTeardown();
      }
    }
  }

  return { apply };
})();

ThemeController.init();
SeasonalTheme.apply('all');

  // Detect mobile (also allow ?mobile=1 for desktop testing, or <body class="force-mobile">)
// Keep this in sync with the CSS breakpoint that switches to the tile/mobile layout
const MOBILE_BREAKPOINT = 1248;

const TABLE_WIDTH_TOLERANCE = 1;
let __tableMinWidthCache = null;

function getTableMinWidth(){
  if (__tableMinWidthCache != null) return __tableMinWidthCache;
  const raw = getComputedStyle(document.documentElement).getPropertyValue('--table-min-width');
  const parsed = parseFloat(raw);
  __tableMinWidthCache = Number.isFinite(parsed) ? parsed : 1100;
  return __tableMinWidthCache;
}

function pageAvailableWidth(){
  const page = document.querySelector('.page');
  return (page?.clientWidth || document.documentElement.clientWidth || window.innerWidth || 0);
}

function viewportWidth(){
  if (typeof window === 'undefined') return 0;
  return Math.max(
    window.innerWidth || 0,
    document.documentElement?.clientWidth || 0,
    document.body?.clientWidth || 0
  );
}

function needsMobileLayout(){
  const minWidth = getTableMinWidth();
  const activeWrap = document.querySelector('.dash[data-active="true"] .table-scroll');

  if (activeWrap && !activeWrap.hidden){
    const available = activeWrap.clientWidth;
    if (available > 0){
      if (available + TABLE_WIDTH_TOLERANCE < minWidth) return true;
      if (available - TABLE_WIDTH_TOLERANCE >= minWidth) return false;
    }
  }

  return pageAvailableWidth() + TABLE_WIDTH_TOLERANCE < minWidth;
}

function isMobileView(){
  if (document.body.classList.contains('force-mobile')) return true;
  if (document.body.classList.contains('force-desktop')) return false;
  if (new URLSearchParams(location.search).has('mobile')) return true;
  const supportsMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';
  if (supportsMatchMedia){
    try{
      if (window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT}px)`).matches) return true;
    }catch(err){
      console.warn?.('[isMobileView] matchMedia failed', err);
    }
  }

  const width = viewportWidth();
  if (width && width <= MOBILE_BREAKPOINT) return true;

  return needsMobileLayout();
}

function cardHTML(row){
  const allCats = String(row['Categories']||'')
    .split(/[,;]+/).map(s=>s.trim()).filter(Boolean);
  const seen = new Set(); const unique = [];
  for (const c of allCats){ const s=slugify(c); if(!seen.has(s)){ seen.add(s); unique.push(c); } }
  const shown = unique.slice(0,4).map(cat=>{
    const { className, style } = chipStyle(cat);
    const styleAttr = style ? ` style="${style}"` : '';
    const classAttr = className ? ` ${className}` : '';
    return `<span class="chip-cat${classAttr}"${styleAttr}>${esc(cat)}</span>`;
  }).join('');
  const more = unique.length>4 ? `<span class="chip-cat" style="opacity:.85;border-style:dashed">+${unique.length-4}</span>` : '';

  const statusCls = statusClass(row['Status']);
  const ms     = row.__ageMs;
  const bucket = row.__ageBucket || ageBucket(ms);
  const ageLbl = getAgeLabel(row);

  // ✅ compute these BEFORE returning the template
  const frozen  = isWinterPlanned(row);
  const ageCls  = `age-chip age-${bucket}` + (frozen ? ' frozen' : '');
  const baseT   = ms != null ? `${(ms/86400000).toFixed(1)} days` : 'Unknown';
  const ageTtl  = frozen ? `Planned for Winter • ${baseT}` : undefined;

  // 🎨 match the Planned Winter Project chip colours when frozen
  const pwp     = categoryColors['planned-winter-project'] || { background:'#E7F3FE', foreground:'#1887FC' };
  const ageStyle = frozen
    ? ` style="--bg:${pwp.background}; --ring: color-mix(in srgb, ${pwp.foreground} 50%, transparent); color:${pwp.foreground}"`
    : '';

  return `
  <article class="mobile-card" role="listitem" aria-label="WO ${esc(row['ID'])}">
    <div class="mobile-card__title">
      <span class="mobile-card__id">#${esc(row['ID'])}</span>
      &nbsp;${esc(row['Title'])}
    </div>
    <div class="mobile-card__badge">
      <span class="status-chip ${statusCls}">${esc(row['Status'])}</span>
    </div>

    <div class="mobile-card__row mobile-card__meta-row">
      <span class="mobile-card__field"><strong>Priority:</strong> ${esc(row['Priority']||'—')}</span>
      <span class="mobile-card__field">
        <strong>Age:</strong>
        <span class="${ageCls}"${ageStyle}${ageTtl ? ` title="${esc(ageTtl)}" aria-label="Planned for Winter"` : ''}>
          ${esc(ageLbl)}
        </span>
      </span>
    </div>

    ${shown || more ? `<div class="mobile-card__row">${shown}${more}</div>` : ''}
  </article>`;
}

__wasMobile = isMobileView();
restoreStoredLayoutMode();
window.addEventListener('resize', ()=>{
  const now = isMobileView();
  if (now !== __wasMobile){
    __wasMobile = now;
    if (LAST_HEADERS && ALL_ROWS) ingestToDashboards(LAST_HEADERS, ALL_ROWS);
    syncLayoutToggle();
  }
});

// Re-render on filter change
function handleFilterChange(){
  const filters = getFilters();
  const nextJson = JSON.stringify(filters);
  const same = __LAST_FILTERS_JSON === nextJson;

  if (same){
    if (!LAST_HEADERS || !ALL_ROWS){
      updateChipsFromFilters(filters);   // <- mapped to `search`
    }
    return;
  }

  __LAST_FILTERS_JSON = nextJson;

  if (LAST_HEADERS && ALL_ROWS){
    ingestToDashboards(LAST_HEADERS, ALL_ROWS);
  } else {
    updateChipsFromFilters(filters);   // <- mapped to `search`
  }
}
$statusFilter?.addEventListener('change', handleFilterChange);
$priorityFilter?.addEventListener('change', handleFilterChange);
$searchInput?.addEventListener('input', debounce(handleFilterChange, 300));
$searchInput?.addEventListener('change', handleFilterChange);

document.addEventListener('click', (e)=>{
  if (legendWrap && !legendWrap.contains(e.target)){
    legendWrap.classList.remove('is-open');
    legendBtn?.setAttribute('aria-expanded','false');
  }
});
  document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && legendWrap?.classList.contains('is-open')){
    legendWrap.classList.remove('is-open');
    legendBtn?.setAttribute('aria-expanded','false');
    legendBtn?.focus();
  }
});
document.fonts?.ready?.then(() => {
  try {
    updateTheadHeight();
    updateStickyControlsOffset();
  } catch {}
});
  const legendWrap = document.querySelector('.legend-popover');
const legendBtn  = document.getElementById('legendBtn');

legendBtn?.addEventListener('click', () => {
  const open = legendWrap.classList.toggle('is-open');
  legendBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
});

document.addEventListener('click', (e)=>{
  if (legendWrap && !legendWrap.contains(e.target)){
    legendWrap.classList.remove('is-open');
    legendBtn?.setAttribute('aria-expanded','false');
  }
});

document.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape' && legendWrap?.classList.contains('is-open')){
    legendWrap.classList.remove('is-open');
    legendBtn?.setAttribute('aria-expanded','false');
    legendBtn?.focus();
  }
});
</script>
</body>
</html>
